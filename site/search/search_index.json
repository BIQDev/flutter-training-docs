{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Pelatihan flutter","title":"Welcome"},{"location":"#pelatihan-flutter","text":"","title":"Pelatihan flutter"},{"location":"crud-rest-api/booklist-mockup/","text":"Book list Mockup Setelah selesai dengan setup provider . Saatnya kita mulai dengan mockup \"Book list\" /daftar buku kita. Siapkan class BookListItem class BookListItem , saat ini masih dalam keadaat ter- hardcode . Artinya, judul, gambar dll kita tulis pada code dan akan selalu static(isinya sama). Variable dan constructor Langkah awal, kita siapkan class BookListItem untuk siap menggunakan variable yang akan kita terima dari REST API nantinya. Buka file lib/widgets/home/book-list-item.dart . Ubah sesuai baris yang ter- highlight berikut: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import 'package:flutter/material.dart' ; class BookListItem extends StatelessWidget { @required final String apiHost ; @required final String id ; @required final String title ; @required final String imagePath ; BookListItem ({ this . apiHost , this . id , this . title , this . imagePath }); @override Widget build ( BuildContext context ) { ... Pada code diatas, kita membuat variable yang @required saat instanisasi pada Constructor. Artinya, class tersebut mensyaratkan variable-variable tersebut selalu disertakan. implementasi variable Setelah pendeklarasian variable diatas, saatnya kita mengubah data-data yang saat ini ter- hardcode . Ubah sesuai baris yang ter- highlight berikut: 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 ... @override Widget build ( BuildContext context ) { return GridTile ( child: Image . network ( \" ${ this . apiHost } /perpus-api/ ${ this . imagePath } \" , width: 80 , height: 80 , fit: BoxFit . cover , ), header: Row ( mainAxisAlignment: MainAxisAlignment . end , children: [ IconButton ( splashColor: Colors . orange [ 100 ], color: Colors . deepOrangeAccent , icon: Icon ( Icons . edit ), onPressed: () {}, ), IconButton ( color: Colors . redAccent , icon: Icon ( Icons . delete ), onPressed: () {}, ), ], ), footer: GridTileBar ( backgroundColor: Colors . black54 , title: Text ( this . title ), trailing: IconButton ( splashColor: Colors . red [ 400 ], icon: Icon ( Icons . favorite ), onPressed: () {}, ), ), ); } } Perubahan: Line 18 , kita rubah type Image yang sebelumnya Image.asset ( mengambil gambar dari local), menjadi Image.network ( mengambil gambar dari server HTTP) Line 19 , kita membentuk URL HTTP gambar dengan variable. Line 42 , kita gunakan variable untuk menampilkan tulisan judul buku. Dynamic Mockup Jika sebelumnya kita Mockup dengan gambar dan text statis, kali ini kita akan mockup dengan text dan gambar dinamis dengan menggunakan variable dilanjutkan dengan provider. Variable mockup Kita awali dengan mencoba menghardcode satu baris BookListItem Buka file lib/widgets/home/book-list.dart , Ubah sesuai baris yang ter- highlight berikut: 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ... class _BookListState extends State < BookList > { @override Widget build ( BuildContext context ) { return GridView . builder ( padding: EdgeInsets . all ( 10 ), itemCount: 1 , itemBuilder: ( ctx , i ) => BookListItem ( id: \"-\" , apiHost: \"https://perpus-api.biqdev.com\" , imagePath: \"assets/book.png\" , title: \"Judul buku mockup\" , ), gridDelegate: SliverGridDelegateWithFixedCrossAxisCount ( crossAxisCount: 2 , childAspectRatio: 8 / 7 , crossAxisSpacing: 10 , mainAxisSpacing: 10 , ), ... Simpan dan jalankan aplikasi kita. Seharusnya tampilannya menjadi seperti ini: Saat ini BookListItem sudah menggunakan variable untuk menampilkan data. Provider mockup Setelah itu, kita mockup dengan data dari provider . Hal ini bertujuan untuk mensimulasikan data yang akan kita terima dari REST API nantinya sudah berada disisi provider . Kita awali dengan me- load provider kita. Masih pada file lib/widgets/home/book-list.dart , ubah sesuai dengan baris yang ter- hightlight berikut: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import 'package:flutter/material.dart' ; import 'package:provider/provider.dart' ; import 'package:perpus/widgets/home/book-list-item.dart' ; import 'package:perpus/models/booklist_model.dart' ; import 'package:perpus/providers/booklist_provider.dart' ; import 'package:perpus/providers/setting_provider.dart' ; class BookList extends StatefulWidget { @override _BookListState createState () => _BookListState (); } class _BookListState extends State < BookList > { @override Widget build ( BuildContext context ) { var apiHost = Provider . of < SettingProvider > ( context , listen: false ). setting . apiHost ; List < BookListModel > bookList = context . watch < BookListProvider > (). list ; return GridView . builder ( ... Line ke-2, load library provider untuk mendapatkan fungsionalitas provider secara otomatis pada context Line ke-5 & 6, import model dan provider Book list kita Line ke-7, kita hanya mengimport provider untuk Setting, karena tidak ada deklarasi model yang rumit. Cukup mengambil string saja. Line ke-17 & 18, ambil variable setting apiHost Line ke-18, kita mengambil data mockup book list dari provider kita Kita gunakan variabel List<BookListModel> bookList yang telah kita deklarasikan pada class BookListItem diatas. Masih pada file yang sama, ubah sesuai baris yang ter- highlight berikut: 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 ... return GridView . builder ( padding: EdgeInsets . all ( 10 ), itemCount: bookList . length , itemBuilder: ( ctx , i ) => BookListItem ( id: bookList [ i ]. id , apiHost: apiHost , imagePath: bookList [ i ]. imagePath , title: bookList [ i ]. title , ), gridDelegate: SliverGridDelegateWithFixedCrossAxisCount ( crossAxisCount: 2 , childAspectRatio: 8 / 7 , crossAxisSpacing: 10 , mainAxisSpacing: 10 , ), ); } ... Pada code diatas, kita gunakan variable bookList yang kita ambil dari provider . Karena variable bookList adalah bertype List , sehingga bisa kita akses dengan menggunakan index yaitu i yang di dapat dari GridView.builder() . Pada class GridView.builder() , secara otomatis akan melakukan loop sesuai angka int yang kita masukkan pada bagian itemCount: bookList.length, . Sehingga itemBuilder: (ctx, i) , nilai i adalah index dari loop sejumlah angka dari itemCount: bookList.length, . Pada contoh provider mockup , kita memasukkan 3 data List bertipe BookListModel . Sehingga jika kita jalankan, hasilnya akan seperti ini:","title":"Booklist mockup"},{"location":"crud-rest-api/booklist-mockup/#book-list-mockup","text":"Setelah selesai dengan setup provider . Saatnya kita mulai dengan mockup \"Book list\" /daftar buku kita.","title":"Book list Mockup"},{"location":"crud-rest-api/booklist-mockup/#siapkan-class-booklistitem","text":"class BookListItem , saat ini masih dalam keadaat ter- hardcode . Artinya, judul, gambar dll kita tulis pada code dan akan selalu static(isinya sama).","title":"Siapkan class BookListItem"},{"location":"crud-rest-api/booklist-mockup/#variable-dan-constructor","text":"Langkah awal, kita siapkan class BookListItem untuk siap menggunakan variable yang akan kita terima dari REST API nantinya. Buka file lib/widgets/home/book-list-item.dart . Ubah sesuai baris yang ter- highlight berikut: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import 'package:flutter/material.dart' ; class BookListItem extends StatelessWidget { @required final String apiHost ; @required final String id ; @required final String title ; @required final String imagePath ; BookListItem ({ this . apiHost , this . id , this . title , this . imagePath }); @override Widget build ( BuildContext context ) { ... Pada code diatas, kita membuat variable yang @required saat instanisasi pada Constructor. Artinya, class tersebut mensyaratkan variable-variable tersebut selalu disertakan.","title":"Variable dan constructor"},{"location":"crud-rest-api/booklist-mockup/#implementasi-variable","text":"Setelah pendeklarasian variable diatas, saatnya kita mengubah data-data yang saat ini ter- hardcode . Ubah sesuai baris yang ter- highlight berikut: 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 ... @override Widget build ( BuildContext context ) { return GridTile ( child: Image . network ( \" ${ this . apiHost } /perpus-api/ ${ this . imagePath } \" , width: 80 , height: 80 , fit: BoxFit . cover , ), header: Row ( mainAxisAlignment: MainAxisAlignment . end , children: [ IconButton ( splashColor: Colors . orange [ 100 ], color: Colors . deepOrangeAccent , icon: Icon ( Icons . edit ), onPressed: () {}, ), IconButton ( color: Colors . redAccent , icon: Icon ( Icons . delete ), onPressed: () {}, ), ], ), footer: GridTileBar ( backgroundColor: Colors . black54 , title: Text ( this . title ), trailing: IconButton ( splashColor: Colors . red [ 400 ], icon: Icon ( Icons . favorite ), onPressed: () {}, ), ), ); } } Perubahan: Line 18 , kita rubah type Image yang sebelumnya Image.asset ( mengambil gambar dari local), menjadi Image.network ( mengambil gambar dari server HTTP) Line 19 , kita membentuk URL HTTP gambar dengan variable. Line 42 , kita gunakan variable untuk menampilkan tulisan judul buku.","title":"implementasi variable"},{"location":"crud-rest-api/booklist-mockup/#dynamic-mockup","text":"Jika sebelumnya kita Mockup dengan gambar dan text statis, kali ini kita akan mockup dengan text dan gambar dinamis dengan menggunakan variable dilanjutkan dengan provider.","title":"Dynamic Mockup"},{"location":"crud-rest-api/booklist-mockup/#variable-mockup","text":"Kita awali dengan mencoba menghardcode satu baris BookListItem Buka file lib/widgets/home/book-list.dart , Ubah sesuai baris yang ter- highlight berikut: 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ... class _BookListState extends State < BookList > { @override Widget build ( BuildContext context ) { return GridView . builder ( padding: EdgeInsets . all ( 10 ), itemCount: 1 , itemBuilder: ( ctx , i ) => BookListItem ( id: \"-\" , apiHost: \"https://perpus-api.biqdev.com\" , imagePath: \"assets/book.png\" , title: \"Judul buku mockup\" , ), gridDelegate: SliverGridDelegateWithFixedCrossAxisCount ( crossAxisCount: 2 , childAspectRatio: 8 / 7 , crossAxisSpacing: 10 , mainAxisSpacing: 10 , ), ... Simpan dan jalankan aplikasi kita. Seharusnya tampilannya menjadi seperti ini: Saat ini BookListItem sudah menggunakan variable untuk menampilkan data.","title":"Variable mockup"},{"location":"crud-rest-api/booklist-mockup/#provider-mockup","text":"Setelah itu, kita mockup dengan data dari provider . Hal ini bertujuan untuk mensimulasikan data yang akan kita terima dari REST API nantinya sudah berada disisi provider . Kita awali dengan me- load provider kita. Masih pada file lib/widgets/home/book-list.dart , ubah sesuai dengan baris yang ter- hightlight berikut: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import 'package:flutter/material.dart' ; import 'package:provider/provider.dart' ; import 'package:perpus/widgets/home/book-list-item.dart' ; import 'package:perpus/models/booklist_model.dart' ; import 'package:perpus/providers/booklist_provider.dart' ; import 'package:perpus/providers/setting_provider.dart' ; class BookList extends StatefulWidget { @override _BookListState createState () => _BookListState (); } class _BookListState extends State < BookList > { @override Widget build ( BuildContext context ) { var apiHost = Provider . of < SettingProvider > ( context , listen: false ). setting . apiHost ; List < BookListModel > bookList = context . watch < BookListProvider > (). list ; return GridView . builder ( ... Line ke-2, load library provider untuk mendapatkan fungsionalitas provider secara otomatis pada context Line ke-5 & 6, import model dan provider Book list kita Line ke-7, kita hanya mengimport provider untuk Setting, karena tidak ada deklarasi model yang rumit. Cukup mengambil string saja. Line ke-17 & 18, ambil variable setting apiHost Line ke-18, kita mengambil data mockup book list dari provider kita Kita gunakan variabel List<BookListModel> bookList yang telah kita deklarasikan pada class BookListItem diatas. Masih pada file yang sama, ubah sesuai baris yang ter- highlight berikut: 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 ... return GridView . builder ( padding: EdgeInsets . all ( 10 ), itemCount: bookList . length , itemBuilder: ( ctx , i ) => BookListItem ( id: bookList [ i ]. id , apiHost: apiHost , imagePath: bookList [ i ]. imagePath , title: bookList [ i ]. title , ), gridDelegate: SliverGridDelegateWithFixedCrossAxisCount ( crossAxisCount: 2 , childAspectRatio: 8 / 7 , crossAxisSpacing: 10 , mainAxisSpacing: 10 , ), ); } ... Pada code diatas, kita gunakan variable bookList yang kita ambil dari provider . Karena variable bookList adalah bertype List , sehingga bisa kita akses dengan menggunakan index yaitu i yang di dapat dari GridView.builder() . Pada class GridView.builder() , secara otomatis akan melakukan loop sesuai angka int yang kita masukkan pada bagian itemCount: bookList.length, . Sehingga itemBuilder: (ctx, i) , nilai i adalah index dari loop sejumlah angka dari itemCount: bookList.length, . Pada contoh provider mockup , kita memasukkan 3 data List bertipe BookListModel . Sehingga jika kita jalankan, hasilnya akan seperti ini:","title":"Provider mockup"},{"location":"crud-rest-api/create-then-read/","text":"(C)reate then (R)ead Saat ini, jika kita menginput data baru yaitu (C)reate, maka saat kembali kehalaman \"Home\", tampilan daftar buku atau \"book list\" kita tidak ada perubahan. Meskipun sebenarnya data sudah terkirim ke server. Untuk itu, kita perlu memasang prosedur (R)ead setelah (C)reate berhasil. Tangkap hasil kembalian input Pertama yang harus kita lakukan adalah menangkap nilai kembalian dari \"screen\" input kita. Hal tersebut bisa didapat dari titik dimana kita memicu/membuka \"screen\" dari input. Yaitu pada file lib/screens/home-page.dart . Buka file tersebut, dan lihat pada baris yang ter-highlight berikut: 5 6 7 8 9 10 11 12 13 14 15 16 17 ... class MyHomePage extends StatelessWidget { MyHomePage ({ Key key }) : super ( key: key ); _newBook ( BuildContext addButtonContext ) async { Navigator . of ( addButtonContext ). pushNamed ( BookInputScreen . routeName , ); } @override Widget build ( BuildContext context ) { ... Pada fungsi _newBook() , saat ini kita hanya membuka BookInputScreen tanpa menangkap hasil kembaliannya. Sekarang kita harus menangkap nilai kembalian dari BookInputScreen pada sebuah variable seperti berikut: 5 6 7 8 9 10 11 12 13 14 15 16 17 ... class MyHomePage extends StatelessWidget { MyHomePage ({ Key key }) : super ( key: key ); _newBook ( BuildContext addButtonContext ) async { final result = await Navigator . of ( addButtonContext ). pushNamed ( BookInputScreen . routeName , ); } @override Widget build ( BuildContext context ) { ... Pada code diatas, baris ke-10, kita menerima nilai kembalian dari BookInputScreen ke variable result . Kemudian nanti variable result akan kita gunakan untuk menentukan jika hasil dari result == 200 , maka akan melakukan (R)ead. 200 adalah standard HTTP code untuk response sukses. Bagian yang menyebabkan BookInputScreen mendapatkan response code 200 adalah dari file lib/screens/book-input.dart pada baris yang ter-highlight berikut: 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 ... if ( submitRes [ \"statusCode\" ] != null && submitRes [ \"statusCode\" ] == 200 ) { Navigator . pop ( context , submitRes [ \"statusCode\" ]); } else { Scaffold . of ( submitContext ) .. removeCurrentSnackBar () .. showSnackBar ( SnackBar ( content: Text ( \"Error \\n - Status: ${ submitRes [ \"statusCode\" ] } \\n - Message: ${ submitRes [ \"message\" ] } \" ), duration: Duration ( seconds: 5 ), backgroundColor: Colors . redAccent . shade400 , ), ); } ... Fungsi Navigator.pop() adalah fungsi untuk menutup \"screen\" dan kembali ke screen berikutnya yaitu screen \"home\". Gunakan variable result Setelah kita buat variable result seperti diatas, dan tahu dari mana nilai kembalian yang didapatkan, saatnya kita gunakan variable tersebut untuk memicu (R)ead jika proses (C)reate selesai. Kembali ke file lib/screens/home-page.dart , tepat dibawah definisi variable result , kita buat sebagaiberikut: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import 'package:flutter/material.dart' ; import 'package:provider/provider.dart' ; import 'package:perpus/screens/book-input.dart' ; import 'package:perpus/widgets/home/book-list.dart' ; import 'package:perpus/widgets/home/header.dart' ; import 'package:perpus/providers/booklist_provider.dart' ; class MyHomePage extends StatelessWidget { MyHomePage ({ Key key }) : super ( key: key ); _newBook ( BuildContext addButtonContext ) async { final result = await Navigator . of ( addButtonContext ). pushNamed ( BookInputScreen . routeName , ); if ( result == 200 ) { Scaffold . of ( addButtonContext ) .. removeCurrentSnackBar () .. showSnackBar ( SnackBar ( content: Text ( \"Berhasil menambah buku\" ), backgroundColor: Colors . greenAccent . shade700 , ), ); addButtonContext . read < BookListProvider > (). read ( addButtonContext ); } } @override Widget build ( BuildContext context ) { return Scaffold ( ... Simpan perubahan diatas, dan untuk memastikan perubahan terload, kita tekan tombol restart . Coba untuk melakukan input data buku baru, kemudian simpan. Jika anda kembali ke halaman \"home\" dan input data baru tampil, maka anda berhasil . Jika tidak, harap periksa kembali, mungkin ada yang salah . Tentang addButtonContext Mungkin ada yang bertanya-tanya tentang addButtonContext ?. Kita perlu addButtonContext karena context pada Widget build(BuildContext context) tidak bisa digunakan untuk melakukan scaffold pada screen lain seperti yang kita perlukan pada BookInputScreen . Untuk itu kita perlu membuat context baru yang akan digunakan scaffold() . Pada kasus ini kita meletakkan pada file lib/screens/home-page.dart , perhatikan code snippet berikut mulai dari line 42 sampai 52: 41 42 43 44 45 46 47 48 49 50 51 52 53 ... floatingActionButton: Builder ( builder: ( BuildContext addButtonContext ) { return FloatingActionButton ( onPressed: () { this . _newBook ( addButtonContext ); }, tooltip: 'New Product' , child: Icon ( Icons . add ), ); }, ), ... Pada code snippet diatas, kita membuat context baru dengan menggunakan Builder() , dengan nama context baru addButtonContext . Jika kita tidak melakukan hal diatas dan memaksa menggunakan context dari Widget build(BuildContext context) , maka kita akan mendapatkan error sebagai berikut: FlutterError (Scaffold.of() called with a context that does not contain a Scaffold. No Scaffold ancestor could be found starting from the context that was passed to Scaffold.of(). This usually happens when the context provided is from the same StatefulWidget as that whose build function actually creates the Scaffold widget being sought. There are several ways to avoid this problem. The simplest is to use a Builder to get a context that is \"under\" the Scaffold. For an example of this, please see the documentation for Scaffold.of(): https://api.flutter.dev/flutter/material/Scaffold/of.html A more efficient solution is to split your build function into several widgets. This introduces a new context from which you can obtain the Scaffold. In this solution, you would have an outer widget that creates the Scaffold populated by instances of your new inner widgets, and then in these inner widgets you would use Scaffold.of(). A less elegant but more expedient solution is assign a GlobalKey to the Scaffold, then use the key.currentState property to obtain the ScaffoldState rather than using the Scaffold.of() function. The context used was: MyHomePage)","title":"(C)eate kemudian (R)ead"},{"location":"crud-rest-api/create-then-read/#create-then-read","text":"Saat ini, jika kita menginput data baru yaitu (C)reate, maka saat kembali kehalaman \"Home\", tampilan daftar buku atau \"book list\" kita tidak ada perubahan. Meskipun sebenarnya data sudah terkirim ke server. Untuk itu, kita perlu memasang prosedur (R)ead setelah (C)reate berhasil.","title":"(C)reate then (R)ead"},{"location":"crud-rest-api/create-then-read/#tangkap-hasil-kembalian-input","text":"Pertama yang harus kita lakukan adalah menangkap nilai kembalian dari \"screen\" input kita. Hal tersebut bisa didapat dari titik dimana kita memicu/membuka \"screen\" dari input. Yaitu pada file lib/screens/home-page.dart . Buka file tersebut, dan lihat pada baris yang ter-highlight berikut: 5 6 7 8 9 10 11 12 13 14 15 16 17 ... class MyHomePage extends StatelessWidget { MyHomePage ({ Key key }) : super ( key: key ); _newBook ( BuildContext addButtonContext ) async { Navigator . of ( addButtonContext ). pushNamed ( BookInputScreen . routeName , ); } @override Widget build ( BuildContext context ) { ... Pada fungsi _newBook() , saat ini kita hanya membuka BookInputScreen tanpa menangkap hasil kembaliannya. Sekarang kita harus menangkap nilai kembalian dari BookInputScreen pada sebuah variable seperti berikut: 5 6 7 8 9 10 11 12 13 14 15 16 17 ... class MyHomePage extends StatelessWidget { MyHomePage ({ Key key }) : super ( key: key ); _newBook ( BuildContext addButtonContext ) async { final result = await Navigator . of ( addButtonContext ). pushNamed ( BookInputScreen . routeName , ); } @override Widget build ( BuildContext context ) { ... Pada code diatas, baris ke-10, kita menerima nilai kembalian dari BookInputScreen ke variable result . Kemudian nanti variable result akan kita gunakan untuk menentukan jika hasil dari result == 200 , maka akan melakukan (R)ead. 200 adalah standard HTTP code untuk response sukses. Bagian yang menyebabkan BookInputScreen mendapatkan response code 200 adalah dari file lib/screens/book-input.dart pada baris yang ter-highlight berikut: 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 ... if ( submitRes [ \"statusCode\" ] != null && submitRes [ \"statusCode\" ] == 200 ) { Navigator . pop ( context , submitRes [ \"statusCode\" ]); } else { Scaffold . of ( submitContext ) .. removeCurrentSnackBar () .. showSnackBar ( SnackBar ( content: Text ( \"Error \\n - Status: ${ submitRes [ \"statusCode\" ] } \\n - Message: ${ submitRes [ \"message\" ] } \" ), duration: Duration ( seconds: 5 ), backgroundColor: Colors . redAccent . shade400 , ), ); } ... Fungsi Navigator.pop() adalah fungsi untuk menutup \"screen\" dan kembali ke screen berikutnya yaitu screen \"home\".","title":"Tangkap hasil kembalian input"},{"location":"crud-rest-api/create-then-read/#gunakan-variable-result","text":"Setelah kita buat variable result seperti diatas, dan tahu dari mana nilai kembalian yang didapatkan, saatnya kita gunakan variable tersebut untuk memicu (R)ead jika proses (C)reate selesai. Kembali ke file lib/screens/home-page.dart , tepat dibawah definisi variable result , kita buat sebagaiberikut: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import 'package:flutter/material.dart' ; import 'package:provider/provider.dart' ; import 'package:perpus/screens/book-input.dart' ; import 'package:perpus/widgets/home/book-list.dart' ; import 'package:perpus/widgets/home/header.dart' ; import 'package:perpus/providers/booklist_provider.dart' ; class MyHomePage extends StatelessWidget { MyHomePage ({ Key key }) : super ( key: key ); _newBook ( BuildContext addButtonContext ) async { final result = await Navigator . of ( addButtonContext ). pushNamed ( BookInputScreen . routeName , ); if ( result == 200 ) { Scaffold . of ( addButtonContext ) .. removeCurrentSnackBar () .. showSnackBar ( SnackBar ( content: Text ( \"Berhasil menambah buku\" ), backgroundColor: Colors . greenAccent . shade700 , ), ); addButtonContext . read < BookListProvider > (). read ( addButtonContext ); } } @override Widget build ( BuildContext context ) { return Scaffold ( ... Simpan perubahan diatas, dan untuk memastikan perubahan terload, kita tekan tombol restart . Coba untuk melakukan input data buku baru, kemudian simpan. Jika anda kembali ke halaman \"home\" dan input data baru tampil, maka anda berhasil . Jika tidak, harap periksa kembali, mungkin ada yang salah .","title":"Gunakan variable result"},{"location":"crud-rest-api/create-then-read/#tentang-addbuttoncontext","text":"Mungkin ada yang bertanya-tanya tentang addButtonContext ?. Kita perlu addButtonContext karena context pada Widget build(BuildContext context) tidak bisa digunakan untuk melakukan scaffold pada screen lain seperti yang kita perlukan pada BookInputScreen . Untuk itu kita perlu membuat context baru yang akan digunakan scaffold() . Pada kasus ini kita meletakkan pada file lib/screens/home-page.dart , perhatikan code snippet berikut mulai dari line 42 sampai 52: 41 42 43 44 45 46 47 48 49 50 51 52 53 ... floatingActionButton: Builder ( builder: ( BuildContext addButtonContext ) { return FloatingActionButton ( onPressed: () { this . _newBook ( addButtonContext ); }, tooltip: 'New Product' , child: Icon ( Icons . add ), ); }, ), ... Pada code snippet diatas, kita membuat context baru dengan menggunakan Builder() , dengan nama context baru addButtonContext . Jika kita tidak melakukan hal diatas dan memaksa menggunakan context dari Widget build(BuildContext context) , maka kita akan mendapatkan error sebagai berikut: FlutterError (Scaffold.of() called with a context that does not contain a Scaffold. No Scaffold ancestor could be found starting from the context that was passed to Scaffold.of(). This usually happens when the context provided is from the same StatefulWidget as that whose build function actually creates the Scaffold widget being sought. There are several ways to avoid this problem. The simplest is to use a Builder to get a context that is \"under\" the Scaffold. For an example of this, please see the documentation for Scaffold.of(): https://api.flutter.dev/flutter/material/Scaffold/of.html A more efficient solution is to split your build function into several widgets. This introduces a new context from which you can obtain the Scaffold. In this solution, you would have an outer widget that creates the Scaffold populated by instances of your new inner widgets, and then in these inner widgets you would use Scaffold.of(). A less elegant but more expedient solution is assign a GlobalKey to the Scaffold, then use the key.currentState property to obtain the ScaffoldState rather than using the Scaffold.of() function. The context used was: MyHomePage)","title":"Tentang addButtonContext"},{"location":"crud-rest-api/create/","text":"(C)reate Meskipun tidak harus selalu memulai dengan (C)reate sesuai urutan dari singkatan CRUD. Dan sepertinya tidak begitu banyak yang menekankan harus (C)reate dahulu, kali ini kita mulai saja sesuai dengan urutan yaitu (C)reate. Mulai dari \"Provider\" Untuk fungsi CRUD, termasuk (C)reate, akan bertempat di provider . Untuk itu, mari kita buka file lib/providers/booklist_provider.dart . Ubah/tambah sesuai dengan baris yang ter- highlight berikut: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 import 'package:flutter/material.dart' ; import 'dart:convert' ; import 'package:path/path.dart' as path ; import 'package:http_parser/http_parser.dart' ; import 'package:http/http.dart' as http ; import 'package:mime/mime.dart' ; import 'package:provider/provider.dart' ; import 'package:perpus/models/booklist_model.dart' ; import 'package:perpus/providers/setting_provider.dart' ; class BookListProvider with ChangeNotifier { // _list ini adalah model utama dari daftar buku kita // akan digunakan untuk menampilkan daftar buku // yang didapat dari REST API List < BookListModel > _list = [ // Kita buat dummy data atau data palsu // hanya untuk tujuan mockup dulu BookListModel ( id: \"1\" , title: \"Judul 1\" , imagePath: \"assets/book.png\" , ), BookListModel ( id: \"2\" , title: \"Judul 2\" , imagePath: \"assets/book.png\" , ), BookListModel ( id: \"3\" , title: \"Judul 3\" , imagePath: \"assets/book.png\" , ), ]; List < BookListModel > get list { return [... this . _list ]; } bool _isCreating = false ; bool get isCreating { return this . _isCreating ; } Future < Map < String , dynamic >> create ( BuildContext context , BookListModel data ) async { this . _isCreating = true ; notifyListeners (); final settingData = Provider . of < SettingProvider > ( context , listen: false ); // Validasi data jika mungkin kosong atau null if ( data == null || data . title == \"\" ) { Map < String , dynamic > resInvalid = new Map < String , dynamic > (); resInvalid [ \"statusCode\" ] = 400 ; resInvalid [ \"message\" ] = \"Input is not valid\" ; this . _isCreating = false ; notifyListeners (); return resInvalid ; } // Membaca data gambar/image untuk diupload List mimeStr = lookupMimeType ( data . imageFile . path ). split ( \"/\" ); var imageBytes = await data . imageFile . readAsBytes (); var uri = Uri . parse ( ' ${ settingData . setting . apiHost } /perpus-api/booklist/ ${ settingData . setting . userName } ' ); // Request HTTP dengan POST verb var request = http . MultipartRequest ( 'POST' , uri ) .. fields [ 'title' ] = data . title .. files . add ( http . MultipartFile . fromBytes ( 'image' , imageBytes , filename: path . basename ( data . imageFile . path ), contentType: MediaType ( mimeStr [ 0 ], mimeStr [ 1 ]))); int statusCode ; try { // Gunakan blok \"try\" karena ada kemungkinan error yang tidak kita ketahui saat ini dari fungsu json.decode() http . StreamedResponse res = await request . send (); statusCode = res . statusCode ; final String respStr = await res . stream . bytesToString (); Map < String , dynamic > resDecoded = json . decode ( respStr ); // Decode JSON resDecoded [ \"statusCode\" ] = res . statusCode ; this . _isCreating = false ; notifyListeners (); //Prosedur standard untuk memberitahu \"listener\" bahwa ada perubahan return resDecoded ; } catch ( e ) { // Jika terjadi error Map < String , dynamic > resInvalid = new Map < String , dynamic > (); resInvalid [ \"statusCode\" ] = statusCode != null ? statusCode : 400 ; resInvalid [ \"message\" ] = e . toString (); this . _isCreating = false ; notifyListeners (); //Prosedur standard untuk memberitahu \"listener\" bahwa ada perubahan return resInvalid ; } } } Pada code diatas, kita menggunakan POST sebagai HTTP verb, hal ini sesuai dengan standard: https://tools.ietf.org/html/rfc2616#section-9.5 UI ( User interface ) UI untuk (C)reate adalah sebuah screen terpisah, yang bisa dibuka dari halaman \"home\". Berikut ini flow UI nya: Trigger trigger atau pemicu adalah sebuah tombol dari halaman \"home\". Buka file lib/screens/home-page.dart , lihat pada code yang ter- highlight dibawah, code tersebut adalah pemicu UI untuk input buku: 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ... class MyHomePage extends StatelessWidget { MyHomePage ({ Key key }) : super ( key: key ); _newBook ( BuildContext addButtonContext ) async { Navigator . of ( addButtonContext ). pushNamed ( BookInputScreen . routeName , ); } @override Widget build ( BuildContext context ) { return Scaffold ( ... Input \"screen\" Input \"screen\" bisa dilihat di lib/screens/book-input.dart . Fungsi dasar untuk input judul dan gambar sudah tersedia. Kita tinggal cukup \"menjahit\" saja dengan REST API untuk (C)reate. Sebenarnya, selain (C)reate, UI ini juga digunakan untuk (U)pdate \"Jahit\" (C)reate REST API Akhirnya... , setelah begitu banyak yang kita lakukan. Saat nya kita mencoba satu bagian dari CRUD yaitu (C)reate. Masih di lib/screens/book-input.dart , ubah/tambah sesuai dengan baris yang ter- highlight berikut ini: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 import 'package:flutter/material.dart' ; import 'dart:io' ; import 'package:image_picker/image_picker.dart' ; import 'package:provider/provider.dart' ; import 'package:perpus/models/booklist_model.dart' ; import 'package:perpus/providers/booklist_provider.dart' ; class BookInputScreenArguments { final String id ; final String title ; final String imagePath ; BookInputScreenArguments ({ this . id , this . title , this . imagePath }); } class BookInputScreen extends StatefulWidget { static const routeName = \"/book-add\" ; @override _BookInputScreenState createState () => _BookInputScreenState (); } class _BookInputScreenState extends State < BookInputScreen > { String _title ; bool _inputIsValid = false ; BookInputScreenArguments _args ; File _image ; final picker = ImagePicker (); Future _pickImage () async { final pickedFile = await picker . getImage ( source : ImageSource . gallery ); setState (() { if ( pickedFile != null ) { _image = File ( pickedFile . path ); this . _setInputValid (); } else { print ( 'No image selected.' ); } }); } void _setInputValid () { this . _inputIsValid = this . _title != null && this . _title != \"\" && this . _image != null ; } bool get inputIsValid { return this . _inputIsValid ; } Future < void > _submit ( BuildContext submitContext ) async { this . _create ( submitContext ); } Future < void > _create ( BuildContext submitContext ) async { final BookListModel inputData = new BookListModel ( id: null , title: this . _title , imagePath: null , imageFile: this . _image , ); final BookListProvider booklistData = Provider . of < BookListProvider > ( submitContext , listen: false ); Map < String , dynamic > submitRes = await booklistData . create ( submitContext , inputData ); if ( submitRes [ \"statusCode\" ] != null && submitRes [ \"statusCode\" ] == 200 ) { Navigator . pop ( context , submitRes [ \"statusCode\" ]); } else { Scaffold . of ( submitContext ) .. removeCurrentSnackBar () .. showSnackBar ( SnackBar ( content: Text ( \"Error \\n - Status: ${ submitRes [ \"statusCode\" ] } \\n - Message: ${ submitRes [ \"message\" ] } \" ), duration: Duration ( seconds: 5 ), backgroundColor: Colors . redAccent . shade400 , ), ); } } @override Widget build ( BuildContext context ) { bool isCreating = context . watch < BookListProvider > (). isCreating ; return Scaffold ( appBar: AppBar ( title: this . _args == null || this . _args . id == null ? const Text ( \"Tambah Buku\" ) : const Text ( \"Edit Buku\" ), ), body: Padding ( padding: const EdgeInsets . all ( 15.0 ), child: Form ( child: SingleChildScrollView ( child: Column ( crossAxisAlignment: CrossAxisAlignment . start , children: < Widget > [ TextFormField ( decoration: InputDecoration ( labelText: 'Title' ), initialValue: this . _title , onChanged: ( v ) { setState (() { this . _title = v ; this . _setInputValid (); }); }, ), SizedBox ( height: 10 ), FlatButton . icon ( icon: Icon ( Icons . image ), onPressed: _pickImage , label: Text ( \"Pick an Image\" ), ), ClipRRect ( borderRadius: BorderRadius . circular ( 8.0 ), child: this . _image == null ? Container () : Image ( image: FileImage ( this . _image ), width: 230 , height: 150 , fit: BoxFit . cover , ), ), SizedBox ( height: 10 ), Builder ( builder: ( BuildContext submitContext ) { return RaisedButton ( child: Text ( \"Simpan\" ), color: Colors . lightBlueAccent , onPressed: ! this . inputIsValid || isCreating ? null : () { this . _submit ( submitContext ); }, ); }), isCreating == false ? Container () : Center ( child: Padding ( padding: const EdgeInsets . only ( top: 50 ), child: CircularProgressIndicator (), ), ) ], ), ), ), ), ); } } Baris 54-56, disini, selain (C)reate, nanti akan dilakukan juga (U)pdate Baris 58-84, adalah block dari logic (C)reate Baris 88, adalah mengambil state dari provider untuk kondisi isCreating , dimana jika bernilai true , berarti sedang melakukan (C)reate ke server HTTP kita. Sebaliknya, jika bernilai false , berarti proses (C)reate sudah selesai Baris 134-138, Tombol akan di disable ( dengan null handler), jika: Input tidak valid isCreating = true , yang berarti sedang ada proses (C)reate ke server HTTP Baris 141-148, Akan menampilkan \"loading indicator\" saat terjadi proses (C)rud. yaitu icon yang berputar-putar, agar user tahu bahwa masih ada proses menyimpan ke server Test input Coba input data judul dan gambar Click simpan Check https://perpus-api.biqdev.com/perpus-api/booklist/ <nama_user> untuk <nama_user> diatas adalah sesuai setting yang kita masukkan pada step SettingProvider Jika anda melihat tampilan kurang lebih seperti ini: { \"status\": \"success\", \"message\": \"\", \"data\": [ { \"id\": \"5fd392d65a98d61f7dc045de\", \"title\": \"Judul 10\", \"image_path\": \"assets/biqdev/1607701206244514318-image_picker274694392.jpg\" } ] } Berarti, selamat , anda berhasil.","title":"(C)reate"},{"location":"crud-rest-api/create/#create","text":"Meskipun tidak harus selalu memulai dengan (C)reate sesuai urutan dari singkatan CRUD. Dan sepertinya tidak begitu banyak yang menekankan harus (C)reate dahulu, kali ini kita mulai saja sesuai dengan urutan yaitu (C)reate.","title":"(C)reate"},{"location":"crud-rest-api/create/#mulai-dari-provider","text":"Untuk fungsi CRUD, termasuk (C)reate, akan bertempat di provider . Untuk itu, mari kita buka file lib/providers/booklist_provider.dart . Ubah/tambah sesuai dengan baris yang ter- highlight berikut: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 import 'package:flutter/material.dart' ; import 'dart:convert' ; import 'package:path/path.dart' as path ; import 'package:http_parser/http_parser.dart' ; import 'package:http/http.dart' as http ; import 'package:mime/mime.dart' ; import 'package:provider/provider.dart' ; import 'package:perpus/models/booklist_model.dart' ; import 'package:perpus/providers/setting_provider.dart' ; class BookListProvider with ChangeNotifier { // _list ini adalah model utama dari daftar buku kita // akan digunakan untuk menampilkan daftar buku // yang didapat dari REST API List < BookListModel > _list = [ // Kita buat dummy data atau data palsu // hanya untuk tujuan mockup dulu BookListModel ( id: \"1\" , title: \"Judul 1\" , imagePath: \"assets/book.png\" , ), BookListModel ( id: \"2\" , title: \"Judul 2\" , imagePath: \"assets/book.png\" , ), BookListModel ( id: \"3\" , title: \"Judul 3\" , imagePath: \"assets/book.png\" , ), ]; List < BookListModel > get list { return [... this . _list ]; } bool _isCreating = false ; bool get isCreating { return this . _isCreating ; } Future < Map < String , dynamic >> create ( BuildContext context , BookListModel data ) async { this . _isCreating = true ; notifyListeners (); final settingData = Provider . of < SettingProvider > ( context , listen: false ); // Validasi data jika mungkin kosong atau null if ( data == null || data . title == \"\" ) { Map < String , dynamic > resInvalid = new Map < String , dynamic > (); resInvalid [ \"statusCode\" ] = 400 ; resInvalid [ \"message\" ] = \"Input is not valid\" ; this . _isCreating = false ; notifyListeners (); return resInvalid ; } // Membaca data gambar/image untuk diupload List mimeStr = lookupMimeType ( data . imageFile . path ). split ( \"/\" ); var imageBytes = await data . imageFile . readAsBytes (); var uri = Uri . parse ( ' ${ settingData . setting . apiHost } /perpus-api/booklist/ ${ settingData . setting . userName } ' ); // Request HTTP dengan POST verb var request = http . MultipartRequest ( 'POST' , uri ) .. fields [ 'title' ] = data . title .. files . add ( http . MultipartFile . fromBytes ( 'image' , imageBytes , filename: path . basename ( data . imageFile . path ), contentType: MediaType ( mimeStr [ 0 ], mimeStr [ 1 ]))); int statusCode ; try { // Gunakan blok \"try\" karena ada kemungkinan error yang tidak kita ketahui saat ini dari fungsu json.decode() http . StreamedResponse res = await request . send (); statusCode = res . statusCode ; final String respStr = await res . stream . bytesToString (); Map < String , dynamic > resDecoded = json . decode ( respStr ); // Decode JSON resDecoded [ \"statusCode\" ] = res . statusCode ; this . _isCreating = false ; notifyListeners (); //Prosedur standard untuk memberitahu \"listener\" bahwa ada perubahan return resDecoded ; } catch ( e ) { // Jika terjadi error Map < String , dynamic > resInvalid = new Map < String , dynamic > (); resInvalid [ \"statusCode\" ] = statusCode != null ? statusCode : 400 ; resInvalid [ \"message\" ] = e . toString (); this . _isCreating = false ; notifyListeners (); //Prosedur standard untuk memberitahu \"listener\" bahwa ada perubahan return resInvalid ; } } } Pada code diatas, kita menggunakan POST sebagai HTTP verb, hal ini sesuai dengan standard: https://tools.ietf.org/html/rfc2616#section-9.5","title":"Mulai dari \"Provider\""},{"location":"crud-rest-api/create/#ui-user-interface","text":"UI untuk (C)reate adalah sebuah screen terpisah, yang bisa dibuka dari halaman \"home\". Berikut ini flow UI nya: Trigger trigger atau pemicu adalah sebuah tombol dari halaman \"home\". Buka file lib/screens/home-page.dart , lihat pada code yang ter- highlight dibawah, code tersebut adalah pemicu UI untuk input buku: 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ... class MyHomePage extends StatelessWidget { MyHomePage ({ Key key }) : super ( key: key ); _newBook ( BuildContext addButtonContext ) async { Navigator . of ( addButtonContext ). pushNamed ( BookInputScreen . routeName , ); } @override Widget build ( BuildContext context ) { return Scaffold ( ... Input \"screen\" Input \"screen\" bisa dilihat di lib/screens/book-input.dart . Fungsi dasar untuk input judul dan gambar sudah tersedia. Kita tinggal cukup \"menjahit\" saja dengan REST API untuk (C)reate. Sebenarnya, selain (C)reate, UI ini juga digunakan untuk (U)pdate","title":"UI ( User interface )"},{"location":"crud-rest-api/create/#jahit-create-rest-api","text":"Akhirnya... , setelah begitu banyak yang kita lakukan. Saat nya kita mencoba satu bagian dari CRUD yaitu (C)reate. Masih di lib/screens/book-input.dart , ubah/tambah sesuai dengan baris yang ter- highlight berikut ini: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 import 'package:flutter/material.dart' ; import 'dart:io' ; import 'package:image_picker/image_picker.dart' ; import 'package:provider/provider.dart' ; import 'package:perpus/models/booklist_model.dart' ; import 'package:perpus/providers/booklist_provider.dart' ; class BookInputScreenArguments { final String id ; final String title ; final String imagePath ; BookInputScreenArguments ({ this . id , this . title , this . imagePath }); } class BookInputScreen extends StatefulWidget { static const routeName = \"/book-add\" ; @override _BookInputScreenState createState () => _BookInputScreenState (); } class _BookInputScreenState extends State < BookInputScreen > { String _title ; bool _inputIsValid = false ; BookInputScreenArguments _args ; File _image ; final picker = ImagePicker (); Future _pickImage () async { final pickedFile = await picker . getImage ( source : ImageSource . gallery ); setState (() { if ( pickedFile != null ) { _image = File ( pickedFile . path ); this . _setInputValid (); } else { print ( 'No image selected.' ); } }); } void _setInputValid () { this . _inputIsValid = this . _title != null && this . _title != \"\" && this . _image != null ; } bool get inputIsValid { return this . _inputIsValid ; } Future < void > _submit ( BuildContext submitContext ) async { this . _create ( submitContext ); } Future < void > _create ( BuildContext submitContext ) async { final BookListModel inputData = new BookListModel ( id: null , title: this . _title , imagePath: null , imageFile: this . _image , ); final BookListProvider booklistData = Provider . of < BookListProvider > ( submitContext , listen: false ); Map < String , dynamic > submitRes = await booklistData . create ( submitContext , inputData ); if ( submitRes [ \"statusCode\" ] != null && submitRes [ \"statusCode\" ] == 200 ) { Navigator . pop ( context , submitRes [ \"statusCode\" ]); } else { Scaffold . of ( submitContext ) .. removeCurrentSnackBar () .. showSnackBar ( SnackBar ( content: Text ( \"Error \\n - Status: ${ submitRes [ \"statusCode\" ] } \\n - Message: ${ submitRes [ \"message\" ] } \" ), duration: Duration ( seconds: 5 ), backgroundColor: Colors . redAccent . shade400 , ), ); } } @override Widget build ( BuildContext context ) { bool isCreating = context . watch < BookListProvider > (). isCreating ; return Scaffold ( appBar: AppBar ( title: this . _args == null || this . _args . id == null ? const Text ( \"Tambah Buku\" ) : const Text ( \"Edit Buku\" ), ), body: Padding ( padding: const EdgeInsets . all ( 15.0 ), child: Form ( child: SingleChildScrollView ( child: Column ( crossAxisAlignment: CrossAxisAlignment . start , children: < Widget > [ TextFormField ( decoration: InputDecoration ( labelText: 'Title' ), initialValue: this . _title , onChanged: ( v ) { setState (() { this . _title = v ; this . _setInputValid (); }); }, ), SizedBox ( height: 10 ), FlatButton . icon ( icon: Icon ( Icons . image ), onPressed: _pickImage , label: Text ( \"Pick an Image\" ), ), ClipRRect ( borderRadius: BorderRadius . circular ( 8.0 ), child: this . _image == null ? Container () : Image ( image: FileImage ( this . _image ), width: 230 , height: 150 , fit: BoxFit . cover , ), ), SizedBox ( height: 10 ), Builder ( builder: ( BuildContext submitContext ) { return RaisedButton ( child: Text ( \"Simpan\" ), color: Colors . lightBlueAccent , onPressed: ! this . inputIsValid || isCreating ? null : () { this . _submit ( submitContext ); }, ); }), isCreating == false ? Container () : Center ( child: Padding ( padding: const EdgeInsets . only ( top: 50 ), child: CircularProgressIndicator (), ), ) ], ), ), ), ), ); } } Baris 54-56, disini, selain (C)reate, nanti akan dilakukan juga (U)pdate Baris 58-84, adalah block dari logic (C)reate Baris 88, adalah mengambil state dari provider untuk kondisi isCreating , dimana jika bernilai true , berarti sedang melakukan (C)reate ke server HTTP kita. Sebaliknya, jika bernilai false , berarti proses (C)reate sudah selesai Baris 134-138, Tombol akan di disable ( dengan null handler), jika: Input tidak valid isCreating = true , yang berarti sedang ada proses (C)reate ke server HTTP Baris 141-148, Akan menampilkan \"loading indicator\" saat terjadi proses (C)rud. yaitu icon yang berputar-putar, agar user tahu bahwa masih ada proses menyimpan ke server","title":"\"Jahit\" (C)reate REST API"},{"location":"crud-rest-api/create/#test-input","text":"Coba input data judul dan gambar Click simpan Check https://perpus-api.biqdev.com/perpus-api/booklist/ <nama_user> untuk <nama_user> diatas adalah sesuai setting yang kita masukkan pada step SettingProvider Jika anda melihat tampilan kurang lebih seperti ini: { \"status\": \"success\", \"message\": \"\", \"data\": [ { \"id\": \"5fd392d65a98d61f7dc045de\", \"title\": \"Judul 10\", \"image_path\": \"assets/biqdev/1607701206244514318-image_picker274694392.jpg\" } ] } Berarti, selamat , anda berhasil.","title":"Test input"},{"location":"crud-rest-api/grid-setup/","text":"Grid setup Langkah awal, kita akan mulai dengan mensetup pada bagian \"Grid\". Ini adalah bagian utama yang akan menampilkan daftar buku yang diinput Pertama, download source code dari: https://github.com/BIQDev/unisnu-flutter-2020.11/tree/crud-0 GridView.builder() Flutter memiliki sebuah class yang bernama GridView . Class tersebut bertujuan untuk mengatur layout dalam tampilan \"grid\". Terdapat berbagai macam metode yang bisa digunakan untuk menginstanisasi class tersebut. Namun untuk tujuan dinamis seperti pada project CRUD ini, dimana jumlah \"child\" dari grid yang ditampilkan akan berubah-ubah, maka akan lebih tepat untuk menggunakan constructor GridView.builder() . Constuctor lain seperti GridView.count() , lebih tepat digunakan untuk menampilkan grid \"child\" yang jumlahnya tetap dan telah ditentukan. Seperti bisa dibaca pada dokumentasi resmi flutter: https://api.flutter.dev/flutter/widgets/GridView-class.html Grid item / \"grid child\" Daftar buku pada \"Grid view\", tiap buku akan ditampilkan dengan sebuah widget yang bernama Gridtile . Widget tersebut adalah bawaan dari flutter, yang memang dikhususkan untuk menjadi \"child\" dari sebuah \"Grid view\". Meskipun sebenarnya kita buat widget sendiri ( custom widget ). Setup asset Langkah awal, kita buat \"mockup\" dari widget yang akan menampilkan buku. Sebelumya kita setup dulu \"asset\" yang kita perlukan untuk \"preview\". Yaitu gambar buku sebagai bagian icon. Untuk itu, kita sudah memiliki sebuah file gambar pada assets/mock/book.png . Kita tinggal import pada file : pubspec.yaml setelah baris 51, sehingga menjadi seperti ini: 50 51 52 assets : - assets/icon/icon-710x710-android.png - assets/mock/book.png \"mock\" tampilan buku Setelah asset di deklarasikan pada file pubspec.yaml diatas, gambar tersebut akan kita tampilkan pada \"mock\" dari GridTile . Buka file lib/widgets/home/book-list.dart . Pada baris ke-14 dengan code: 14 itemBuilder: ( ctx , i ) => Text ( \"Dummy\" ), Kita hapus dan ubah dengan widget GridTile sebagai berikut: 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 itemBuilder: ( ctx , i ) => GridTile ( child: Image . asset ( \"assets/mock/book.png\" , width: 80 , height: 80 , fit: BoxFit . cover , ), footer: GridTileBar ( backgroundColor: Colors . black54 , title: Text ( \"Judulnya\" ), trailing: IconButton ( splashColor: Colors . red [ 400 ], icon: Icon ( Icons . favorite ), onPressed: () {}, ), ), ), Simpan, dan seharusnya, setelah selesai \"hot reload\" kita mendapatkan tampilan seperti berikut ini: Buat \"custom widget\" grid item Setelah cukup puas dengan \"mockup\" pada tampilan Grid Item kita, pindahkan GridTile() ke widget terpisah. Hal ini memudahkan kita untuk mengembangkan Grid Item tersebut lebih detail secara terpisah dan substansial. Buat file lib/widgets/home/book-list-item.dart Pindahkan GridTile() dari lib/widgets/home/book-list.dart line 14, pindahkan ke file baru diatas. Sehingga, file lib/widgets/home/book-list-item.dart akan menjadi seperti dibawah ini: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import 'package:flutter/material.dart' ; class BookListItem extends StatelessWidget { @override Widget build ( BuildContext context ) { return GridTile ( child: Image . asset ( \"assets/mock/book.png\" , width: 80 , height: 80 , fit: BoxFit . cover , ), footer: GridTileBar ( backgroundColor: Colors . black54 , title: Text ( \"Judulnya\" ), trailing: IconButton ( splashColor: Colors . red [ 400 ], icon: Icon ( Icons . favorite ), onPressed: () {}, ), ), ); } } Pada file lib/widgets/home/book-list.dart line 3, Tambahkan: 1 2 3 4 5 6 import 'package:flutter/material.dart' ; import 'package:perpus/widgets/home/book-list-item.dart' ; class BookList extends StatefulWidget { ... Kemudian line 16 menjadi 16 itemBuilder: ( ctx , i ) => BookListItem (), Grid item detail Pada bagian ini kita akan memberikan sedikit detail pada \"grid item\" kita. Terutama untuk tujuan navigasi yang berkaitan dengan CRUD, yaitu pada bagian update dan delete Beralih kembali ke file lib/widgets/home/book-list-item.dart buat baris baru setelah baris ke-12. Pada baris ke-13, masukkan kode berikut: 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 header: Row ( mainAxisAlignment: MainAxisAlignment . end , children: [ IconButton ( splashColor: Colors . orange [ 100 ], color: Colors . deepOrangeAccent , icon: Icon ( Icons . edit ), onPressed: () {}, ), IconButton ( color: Colors . redAccent , icon: Icon ( Icons . delete ), onPressed: () {}, ), ], ), Akan muncul 2 tombol pada bagian header dari \"grid item\" seperti pada screenshot berikut: Saat ini tombolnya masih belum memiliki fungsi apa pun, segera kita akan mem- bind fungsi update dan delete ke tombol tersebut.","title":"Grid Setup"},{"location":"crud-rest-api/grid-setup/#grid-setup","text":"Langkah awal, kita akan mulai dengan mensetup pada bagian \"Grid\". Ini adalah bagian utama yang akan menampilkan daftar buku yang diinput Pertama, download source code dari: https://github.com/BIQDev/unisnu-flutter-2020.11/tree/crud-0","title":"Grid setup"},{"location":"crud-rest-api/grid-setup/#gridviewbuilder","text":"Flutter memiliki sebuah class yang bernama GridView . Class tersebut bertujuan untuk mengatur layout dalam tampilan \"grid\". Terdapat berbagai macam metode yang bisa digunakan untuk menginstanisasi class tersebut. Namun untuk tujuan dinamis seperti pada project CRUD ini, dimana jumlah \"child\" dari grid yang ditampilkan akan berubah-ubah, maka akan lebih tepat untuk menggunakan constructor GridView.builder() . Constuctor lain seperti GridView.count() , lebih tepat digunakan untuk menampilkan grid \"child\" yang jumlahnya tetap dan telah ditentukan. Seperti bisa dibaca pada dokumentasi resmi flutter: https://api.flutter.dev/flutter/widgets/GridView-class.html","title":"GridView.builder()"},{"location":"crud-rest-api/grid-setup/#grid-item-grid-child","text":"Daftar buku pada \"Grid view\", tiap buku akan ditampilkan dengan sebuah widget yang bernama Gridtile . Widget tersebut adalah bawaan dari flutter, yang memang dikhususkan untuk menjadi \"child\" dari sebuah \"Grid view\". Meskipun sebenarnya kita buat widget sendiri ( custom widget ).","title":"Grid item / \"grid child\""},{"location":"crud-rest-api/grid-setup/#setup-asset","text":"Langkah awal, kita buat \"mockup\" dari widget yang akan menampilkan buku. Sebelumya kita setup dulu \"asset\" yang kita perlukan untuk \"preview\". Yaitu gambar buku sebagai bagian icon. Untuk itu, kita sudah memiliki sebuah file gambar pada assets/mock/book.png . Kita tinggal import pada file : pubspec.yaml setelah baris 51, sehingga menjadi seperti ini: 50 51 52 assets : - assets/icon/icon-710x710-android.png - assets/mock/book.png","title":"Setup asset"},{"location":"crud-rest-api/grid-setup/#mock-tampilan-buku","text":"Setelah asset di deklarasikan pada file pubspec.yaml diatas, gambar tersebut akan kita tampilkan pada \"mock\" dari GridTile . Buka file lib/widgets/home/book-list.dart . Pada baris ke-14 dengan code: 14 itemBuilder: ( ctx , i ) => Text ( \"Dummy\" ), Kita hapus dan ubah dengan widget GridTile sebagai berikut: 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 itemBuilder: ( ctx , i ) => GridTile ( child: Image . asset ( \"assets/mock/book.png\" , width: 80 , height: 80 , fit: BoxFit . cover , ), footer: GridTileBar ( backgroundColor: Colors . black54 , title: Text ( \"Judulnya\" ), trailing: IconButton ( splashColor: Colors . red [ 400 ], icon: Icon ( Icons . favorite ), onPressed: () {}, ), ), ), Simpan, dan seharusnya, setelah selesai \"hot reload\" kita mendapatkan tampilan seperti berikut ini:","title":"\"mock\" tampilan buku"},{"location":"crud-rest-api/grid-setup/#buat-custom-widget-grid-item","text":"Setelah cukup puas dengan \"mockup\" pada tampilan Grid Item kita, pindahkan GridTile() ke widget terpisah. Hal ini memudahkan kita untuk mengembangkan Grid Item tersebut lebih detail secara terpisah dan substansial. Buat file lib/widgets/home/book-list-item.dart Pindahkan GridTile() dari lib/widgets/home/book-list.dart line 14, pindahkan ke file baru diatas. Sehingga, file lib/widgets/home/book-list-item.dart akan menjadi seperti dibawah ini: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import 'package:flutter/material.dart' ; class BookListItem extends StatelessWidget { @override Widget build ( BuildContext context ) { return GridTile ( child: Image . asset ( \"assets/mock/book.png\" , width: 80 , height: 80 , fit: BoxFit . cover , ), footer: GridTileBar ( backgroundColor: Colors . black54 , title: Text ( \"Judulnya\" ), trailing: IconButton ( splashColor: Colors . red [ 400 ], icon: Icon ( Icons . favorite ), onPressed: () {}, ), ), ); } } Pada file lib/widgets/home/book-list.dart line 3, Tambahkan: 1 2 3 4 5 6 import 'package:flutter/material.dart' ; import 'package:perpus/widgets/home/book-list-item.dart' ; class BookList extends StatefulWidget { ... Kemudian line 16 menjadi 16 itemBuilder: ( ctx , i ) => BookListItem (),","title":"Buat \"custom widget\" grid item"},{"location":"crud-rest-api/grid-setup/#grid-item-detail","text":"Pada bagian ini kita akan memberikan sedikit detail pada \"grid item\" kita. Terutama untuk tujuan navigasi yang berkaitan dengan CRUD, yaitu pada bagian update dan delete Beralih kembali ke file lib/widgets/home/book-list-item.dart buat baris baru setelah baris ke-12. Pada baris ke-13, masukkan kode berikut: 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 header: Row ( mainAxisAlignment: MainAxisAlignment . end , children: [ IconButton ( splashColor: Colors . orange [ 100 ], color: Colors . deepOrangeAccent , icon: Icon ( Icons . edit ), onPressed: () {}, ), IconButton ( color: Colors . redAccent , icon: Icon ( Icons . delete ), onPressed: () {}, ), ], ), Akan muncul 2 tombol pada bagian header dari \"grid item\" seperti pada screenshot berikut: Saat ini tombolnya masih belum memiliki fungsi apa pun, segera kita akan mem- bind fungsi update dan delete ke tombol tersebut.","title":"Grid item detail"},{"location":"crud-rest-api/overview/","text":"Overview Rencana pengembangan aplikasi Layout Berikut ini layout aplikasi android yang akan kita buat. Pada A. Layout halaman utama ( Home ) Halaman utama / home terdiri dari 3 widget seperti pada screenshot berikut. Layout tersebut dibentuk pada code: lib/screens/home-page.dart 1. Header Komponen header pada screenshot diatas adalah sebuah \"custom widget\" yang di definisikan pada file : lib/widgets/home/header.dart 2. Grid view Pada bagian grid view ini nanti akan tampil daftar buku. Bagian ini juga dibuat dengan custom widget yang didefinisikan pada file: lib/widgets/home/book-list.dart 3. Floating button Bagian terakhir ini ada tombol yang akan menampilkan \"screen\" baru, yaitu screen \"input\". REST API Interface CRUD yang akan kita gunakan adalah REST API. Struktur URL REST API kita adalah sebagai berikut: <host>/perpus-api/booklist/<user_name> <host> adalah alamat dimana REST API kita di host. Misal http://127.0.0.1, http://localhost atau https://www.biqdev.com <user_name> setiap user akan memiliki tampilan sendiri sesuai dengan user name yang dipilih.","title":"Overview"},{"location":"crud-rest-api/overview/#overview","text":"Rencana pengembangan aplikasi","title":"Overview"},{"location":"crud-rest-api/overview/#layout","text":"Berikut ini layout aplikasi android yang akan kita buat. Pada","title":"Layout"},{"location":"crud-rest-api/overview/#a-layout-halaman-utama-home","text":"Halaman utama / home terdiri dari 3 widget seperti pada screenshot berikut. Layout tersebut dibentuk pada code: lib/screens/home-page.dart","title":"A. Layout halaman utama ( Home )"},{"location":"crud-rest-api/overview/#1-header","text":"Komponen header pada screenshot diatas adalah sebuah \"custom widget\" yang di definisikan pada file : lib/widgets/home/header.dart","title":"1. Header"},{"location":"crud-rest-api/overview/#2-grid-view","text":"Pada bagian grid view ini nanti akan tampil daftar buku. Bagian ini juga dibuat dengan custom widget yang didefinisikan pada file: lib/widgets/home/book-list.dart","title":"2. Grid view"},{"location":"crud-rest-api/overview/#3-floating-button","text":"Bagian terakhir ini ada tombol yang akan menampilkan \"screen\" baru, yaitu screen \"input\".","title":"3. Floating button"},{"location":"crud-rest-api/overview/#rest-api","text":"Interface CRUD yang akan kita gunakan adalah REST API. Struktur URL REST API kita adalah sebagai berikut: <host>/perpus-api/booklist/<user_name> <host> adalah alamat dimana REST API kita di host. Misal http://127.0.0.1, http://localhost atau https://www.biqdev.com <user_name> setiap user akan memiliki tampilan sendiri sesuai dengan user name yang dipilih.","title":"REST API"},{"location":"crud-rest-api/provider-setup/","text":"Provider setup Pada bagian ini, kita akan membuat 2 buah provider, yaitu: Setting Provider ini digunakan untuk mendefinisikan setting. Dalam hal ini hanya untuk menentukan <host> dan <user_name> pada REST API sesuai dengan yang telah dijelaskan pada halaman overview REST API Sebenarnya untuk setting tidak harus selalu menggunakan provider , dalam project ini hanya untuk kita jadikan contoh simple pembuatan provider yang sederhana. Namun tidak ada salahnya pada project real menggunakan provider untuk menyimpan setting. Karena bisa diakses darimana saja. Book List Daftar buku yang didapat dari CRUD khususnya bagian (R)ead, akan disimpan pada provider ini. Selain state yang menyimpan daftar buku, juga akan ada state lain seperti: _isReading , yaitu state yang akan bernilai true saat proses (R)ead terjadi. Dan bernilai false saat proses (R)ead selesai. Hal ini bertujuan untuk mengatur tampilan UI . Dimana saat bernilai true , UI akan menampilkan loading indicator , sedangkan saat bernilai false , UI akan menampilkan daftar buku. _isCreating hampir sama dengan _isReading , hanya saja ini digunakan pada proses (C)reate. Langkah awal Pertama, buat 2 directory: models Untuk menyimpan file-file definisi model yang akan digunakan provider providers Untuk menyimpan file-file definisi provider itu sendiri Provider untuk Setting Kita mulai dengan provider untuk setting. Seperti yang tertulis di Membuat provider , secara umum kita perlu membuat model dan provider . SettingModel Buat file lib/models/setting_model.dart , masukkan code berikut: 1 2 3 4 5 6 class SettingModel { final String apiHost ; final String userName ; SettingModel ({ this . apiHost , this . userName }); } ada 2 variable yang akan digunakan pada model ini. Yaitu apiHost dan userName . Seperti dijelaskan sebelumnya, variable tersebut akan digunakan untuk menentukan URL dari REST API. SettingProvider Buat file lib/providers/setting_provider.dart , kemudian copy code berikut kedalamnya: 1 2 3 4 5 6 7 8 9 10 11 12 13 import 'package:flutter/material.dart' ; import 'package:perpus/models/setting_model.dart' ; class SettingProvider with ChangeNotifier { SettingModel _setting = SettingModel ( apiHost: \"https://perpus-api.biqdev.com\" , userName: \"nama-anda\" , ); SettingModel get setting { return _setting ; } } Catatan penting , untuk setting ini, provider yang akan digunakan adalah type static . Tidak seperti provider yang nanti akan kita pakai untuk daftar buku( book list ) yang bersifat dynamic . Karena provider untuk book list akan berubah-ubah sesuai data dari server REST API seperti dijelaskan sebelumnya with ChangeNotifier adalah sebuah metode mixin agar class yang kita buat dapat berkomunikasi dengan listener nya. apiHost diatas sudah running dan siap pakai. Jika ingin serve sendiri, REST API tersebut bisa setting sendiri dengan mendapatkan source dari : https://github.com/BIQDev/perpus-api Ganti userName dengan nama anda, usahakan unik dan tidak dipakai user lain agar tidak terjadi konflik. Untuk simpelnya, kita tidak ada proses registrasi SettingModel get setting{} , seperti dijelaskan sebelumnya adalah getter dari variable state yaitu _setting ( private variable) \"Jahit\" provider Sebelum kita membuat provider lain, marilah kita \"jahit\" dulu satu provider yang baru saja kita buat. Semua provider-provider yang akan kita buat nantinya, akan menjadi \"root\" , atau \"akar\"/awal dari \"widget tree\"/\"pohon widget\" kita. Agar widget-widget lain berada dibawah dari provider , sehingga semua widget pada apps kita, secara architecture bisa mengambil data dari provider yang kita buat. Berikut ini step nya: buka file lib/main.dart import provider , buat line baru setelah line ke-1 ( line ke-2 ). 2 import 'package:provider/provider.dart' ; import provider seting yang sudah kita buat. Buat line baru setelah line ke-5: 6 import 'package:perpus/providers/setting_provider.dart' ; lihat pada line ke-15, kita akan membuat widget MaterialApp yang awalnya sebagai root widget dari aplikasi kita, akan menjadi child dari provider hapus line ke-16 s/d line ke-25 yaitu: 16 17 18 19 20 21 22 23 24 25 return MaterialApp ( title: 'Perpus' , theme: ThemeData ( primarySwatch: Colors . blue , ), home: MyHomePage (), routes: { BookInputScreen . routeName: ( ctx ) => BookInputScreen (), }, ); ganti dengan code berikut: 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 return MultiProvider ( providers: [ ChangeNotifierProvider ( create: ( _ ) => SettingProvider ()), ], child: MaterialApp ( title: 'Perpus' , theme: ThemeData ( primarySwatch: Colors . blue , ), home: MyHomePage (), routes: { BookInputScreen . routeName: ( ctx ) => BookInputScreen (), }, ), ); Code diatas, pada dasarnya memindahkan MaterialApp(...) yang sebelumnya sebagi \"root\" menjadi \"child\". Provider untuk Booklist Inilah provider utama kita. Yang akan kita gunakan untuk CRUD. Provider ini bersifat dinamis, artinya akan berubah-ubah sesuai data yang kita dapat dari server REST API ( Saat Create, Update dan Delete ) BookListModel Seperti yang telah dijelaskan dan kita buat, langkah pertama adalah membuat model dari provider kita. Buat file baru di lib/models/booklist_model.dart . Masukkan code berikut: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import 'dart:io' ; import 'package:flutter/foundation.dart' ; class BookListModel { final String id ; // id dari record didatabase final String title ; // Judul buku final String imagePath ; // URL gambar dari buku/sampul buku final File imageFile ; // Untuk handle file upload berupa object File BookListModel ({ @required this . id , @required this . title , @required this . imagePath , this . imageFile , }); /* fromJson() digunakan untuk konversi data JSON * yang diterima dari REST API * Menjadi Map<String, dynamic> */ BookListModel . fromJson ( Map < String , dynamic > json ) : id = json [ 'id' ], title = json [ 'title' ], imagePath = json [ 'image_path' ], imageFile = json [ \"image_file\" ]; } BookListProvider Kemudian setelah model selesai, kita buat class untuk provider nya. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import 'package:flutter/material.dart' ; import 'package:perpus/models/booklist_model.dart' ; class BookListProvider with ChangeNotifier { // _list ini adalah model utama dari daftar buku kita // akan digunakan untuk menampilkan daftar buku // yang didapat dari REST API List < BookListModel > _list = [ // Kita buat dummy data atau data palsu // hanya untuk tujuan mockup dulu BookListModel ( id: \"1\" , title: \"Judul 1\" , imagePath: \"assets/book.png\" , ), BookListModel ( id: \"2\" , title: \"Judul 2\" , imagePath: \"assets/book.png\" , ), BookListModel ( id: \"3\" , title: \"Judul 3\" , imagePath: \"assets/book.png\" , ), ]; List < BookListModel > get list { return [... this . _list ]; } } \"Jahit\" BookListProvider Seperti yang kita lakukan pada SettingProvider , kita harus \"menjahit\" provider baru kita yaitu BookListProvider . Buka file lib/main.dart , ubah sesuai baris yang ter- highlight berikut: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import 'package:flutter/material.dart' ; import 'package:perpus/providers/booklist_provider.dart' ; import 'package:provider/provider.dart' ; import 'package:perpus/screens/book-input.dart' ; import 'package:perpus/screens/home-page.dart' ; import 'package:perpus/providers/setting_provider.dart' ; void main () { runApp ( MyApp ()); } class MyApp extends StatelessWidget { // This widget is the root of your application. @override Widget build ( BuildContext context ) { return MultiProvider ( providers: [ ChangeNotifierProvider ( create: ( _ ) => SettingProvider ()), ChangeNotifierProvider ( create: ( _ ) => BookListProvider ()), ], child: MaterialApp ( title: 'Perpus' , theme: ThemeData ( primarySwatch: Colors . blue , ), home: MyHomePage (), routes: { BookInputScreen . routeName: ( ctx ) => BookInputScreen (), }, ), ); } }","title":"Provider setup"},{"location":"crud-rest-api/provider-setup/#provider-setup","text":"Pada bagian ini, kita akan membuat 2 buah provider, yaitu: Setting Provider ini digunakan untuk mendefinisikan setting. Dalam hal ini hanya untuk menentukan <host> dan <user_name> pada REST API sesuai dengan yang telah dijelaskan pada halaman overview REST API Sebenarnya untuk setting tidak harus selalu menggunakan provider , dalam project ini hanya untuk kita jadikan contoh simple pembuatan provider yang sederhana. Namun tidak ada salahnya pada project real menggunakan provider untuk menyimpan setting. Karena bisa diakses darimana saja. Book List Daftar buku yang didapat dari CRUD khususnya bagian (R)ead, akan disimpan pada provider ini. Selain state yang menyimpan daftar buku, juga akan ada state lain seperti: _isReading , yaitu state yang akan bernilai true saat proses (R)ead terjadi. Dan bernilai false saat proses (R)ead selesai. Hal ini bertujuan untuk mengatur tampilan UI . Dimana saat bernilai true , UI akan menampilkan loading indicator , sedangkan saat bernilai false , UI akan menampilkan daftar buku. _isCreating hampir sama dengan _isReading , hanya saja ini digunakan pada proses (C)reate.","title":"Provider setup"},{"location":"crud-rest-api/provider-setup/#langkah-awal","text":"Pertama, buat 2 directory: models Untuk menyimpan file-file definisi model yang akan digunakan provider providers Untuk menyimpan file-file definisi provider itu sendiri","title":"Langkah awal"},{"location":"crud-rest-api/provider-setup/#provider-untuk-setting","text":"Kita mulai dengan provider untuk setting. Seperti yang tertulis di Membuat provider , secara umum kita perlu membuat model dan provider .","title":"Provider untuk Setting"},{"location":"crud-rest-api/provider-setup/#settingmodel","text":"Buat file lib/models/setting_model.dart , masukkan code berikut: 1 2 3 4 5 6 class SettingModel { final String apiHost ; final String userName ; SettingModel ({ this . apiHost , this . userName }); } ada 2 variable yang akan digunakan pada model ini. Yaitu apiHost dan userName . Seperti dijelaskan sebelumnya, variable tersebut akan digunakan untuk menentukan URL dari REST API.","title":"SettingModel"},{"location":"crud-rest-api/provider-setup/#settingprovider","text":"Buat file lib/providers/setting_provider.dart , kemudian copy code berikut kedalamnya: 1 2 3 4 5 6 7 8 9 10 11 12 13 import 'package:flutter/material.dart' ; import 'package:perpus/models/setting_model.dart' ; class SettingProvider with ChangeNotifier { SettingModel _setting = SettingModel ( apiHost: \"https://perpus-api.biqdev.com\" , userName: \"nama-anda\" , ); SettingModel get setting { return _setting ; } } Catatan penting , untuk setting ini, provider yang akan digunakan adalah type static . Tidak seperti provider yang nanti akan kita pakai untuk daftar buku( book list ) yang bersifat dynamic . Karena provider untuk book list akan berubah-ubah sesuai data dari server REST API seperti dijelaskan sebelumnya with ChangeNotifier adalah sebuah metode mixin agar class yang kita buat dapat berkomunikasi dengan listener nya. apiHost diatas sudah running dan siap pakai. Jika ingin serve sendiri, REST API tersebut bisa setting sendiri dengan mendapatkan source dari : https://github.com/BIQDev/perpus-api Ganti userName dengan nama anda, usahakan unik dan tidak dipakai user lain agar tidak terjadi konflik. Untuk simpelnya, kita tidak ada proses registrasi SettingModel get setting{} , seperti dijelaskan sebelumnya adalah getter dari variable state yaitu _setting ( private variable)","title":"SettingProvider"},{"location":"crud-rest-api/provider-setup/#jahit-provider","text":"Sebelum kita membuat provider lain, marilah kita \"jahit\" dulu satu provider yang baru saja kita buat. Semua provider-provider yang akan kita buat nantinya, akan menjadi \"root\" , atau \"akar\"/awal dari \"widget tree\"/\"pohon widget\" kita. Agar widget-widget lain berada dibawah dari provider , sehingga semua widget pada apps kita, secara architecture bisa mengambil data dari provider yang kita buat. Berikut ini step nya: buka file lib/main.dart import provider , buat line baru setelah line ke-1 ( line ke-2 ). 2 import 'package:provider/provider.dart' ; import provider seting yang sudah kita buat. Buat line baru setelah line ke-5: 6 import 'package:perpus/providers/setting_provider.dart' ; lihat pada line ke-15, kita akan membuat widget MaterialApp yang awalnya sebagai root widget dari aplikasi kita, akan menjadi child dari provider hapus line ke-16 s/d line ke-25 yaitu: 16 17 18 19 20 21 22 23 24 25 return MaterialApp ( title: 'Perpus' , theme: ThemeData ( primarySwatch: Colors . blue , ), home: MyHomePage (), routes: { BookInputScreen . routeName: ( ctx ) => BookInputScreen (), }, ); ganti dengan code berikut: 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 return MultiProvider ( providers: [ ChangeNotifierProvider ( create: ( _ ) => SettingProvider ()), ], child: MaterialApp ( title: 'Perpus' , theme: ThemeData ( primarySwatch: Colors . blue , ), home: MyHomePage (), routes: { BookInputScreen . routeName: ( ctx ) => BookInputScreen (), }, ), ); Code diatas, pada dasarnya memindahkan MaterialApp(...) yang sebelumnya sebagi \"root\" menjadi \"child\".","title":"\"Jahit\" provider"},{"location":"crud-rest-api/provider-setup/#provider-untuk-booklist","text":"Inilah provider utama kita. Yang akan kita gunakan untuk CRUD. Provider ini bersifat dinamis, artinya akan berubah-ubah sesuai data yang kita dapat dari server REST API ( Saat Create, Update dan Delete )","title":"Provider untuk Booklist"},{"location":"crud-rest-api/provider-setup/#booklistmodel","text":"Seperti yang telah dijelaskan dan kita buat, langkah pertama adalah membuat model dari provider kita. Buat file baru di lib/models/booklist_model.dart . Masukkan code berikut: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import 'dart:io' ; import 'package:flutter/foundation.dart' ; class BookListModel { final String id ; // id dari record didatabase final String title ; // Judul buku final String imagePath ; // URL gambar dari buku/sampul buku final File imageFile ; // Untuk handle file upload berupa object File BookListModel ({ @required this . id , @required this . title , @required this . imagePath , this . imageFile , }); /* fromJson() digunakan untuk konversi data JSON * yang diterima dari REST API * Menjadi Map<String, dynamic> */ BookListModel . fromJson ( Map < String , dynamic > json ) : id = json [ 'id' ], title = json [ 'title' ], imagePath = json [ 'image_path' ], imageFile = json [ \"image_file\" ]; }","title":"BookListModel"},{"location":"crud-rest-api/provider-setup/#booklistprovider","text":"Kemudian setelah model selesai, kita buat class untuk provider nya. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import 'package:flutter/material.dart' ; import 'package:perpus/models/booklist_model.dart' ; class BookListProvider with ChangeNotifier { // _list ini adalah model utama dari daftar buku kita // akan digunakan untuk menampilkan daftar buku // yang didapat dari REST API List < BookListModel > _list = [ // Kita buat dummy data atau data palsu // hanya untuk tujuan mockup dulu BookListModel ( id: \"1\" , title: \"Judul 1\" , imagePath: \"assets/book.png\" , ), BookListModel ( id: \"2\" , title: \"Judul 2\" , imagePath: \"assets/book.png\" , ), BookListModel ( id: \"3\" , title: \"Judul 3\" , imagePath: \"assets/book.png\" , ), ]; List < BookListModel > get list { return [... this . _list ]; } }","title":"BookListProvider"},{"location":"crud-rest-api/provider-setup/#jahit-booklistprovider","text":"Seperti yang kita lakukan pada SettingProvider , kita harus \"menjahit\" provider baru kita yaitu BookListProvider . Buka file lib/main.dart , ubah sesuai baris yang ter- highlight berikut: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import 'package:flutter/material.dart' ; import 'package:perpus/providers/booklist_provider.dart' ; import 'package:provider/provider.dart' ; import 'package:perpus/screens/book-input.dart' ; import 'package:perpus/screens/home-page.dart' ; import 'package:perpus/providers/setting_provider.dart' ; void main () { runApp ( MyApp ()); } class MyApp extends StatelessWidget { // This widget is the root of your application. @override Widget build ( BuildContext context ) { return MultiProvider ( providers: [ ChangeNotifierProvider ( create: ( _ ) => SettingProvider ()), ChangeNotifierProvider ( create: ( _ ) => BookListProvider ()), ], child: MaterialApp ( title: 'Perpus' , theme: ThemeData ( primarySwatch: Colors . blue , ), home: MyHomePage (), routes: { BookInputScreen . routeName: ( ctx ) => BookInputScreen (), }, ), ); } }","title":"\"Jahit\" BookListProvider"},{"location":"crud-rest-api/provider/","text":"Provider Provider digunakan untuk beberapa tujuan. Salah satu kegunaan utamanya adalah untuk CRUD pada project pelatihan ini. Pada umumnya provider disebut juga sebagai state management , dimana sebuah aplikasi memiliki satu sumber data untuk semua user interface . Kita bisa membayangkan provider ini seperti database yang berisi satu atau lebih table . Sehingga, pada penggunaan dengan tujuan CRUD, provider berfungsi seperti database sementara pada saat terjadi Read dari server. Latar belakang penggunaan provider Konsep provider pada Flutter, sudah banyak dan populer digunakan pada platform lain, seperti Redux pada RreactJS atau NgRx dan NgXs pada Angular . Sebelum konspe state management seperti provider ini populer, data pada aplikasi antar user interface biasanya di pass berupa variable biasa dengan mengakses module/instance dari user interface yang memiliki data terkait. Hal ini akan sangat merepotkan, bayangkan saat kita memiliki sebuah input dialog , dari situ kita memerlukan data dari UI lain misal dari panel utama, kita harus memikirkan bagamana mem- pass data dari panel utama ke UI input dialog tersebut. Terlebih lagi jika pada suatu titik terjadi perubahan data pada panel utama tersebut. Dibandingkan dengan kosep provider ini atau yang umumnya disebut juga dengan state management . Data akan dapat diakses pada satu instance khusus. Jadi aplikasi kita akan memiliki single source of truth , yaitu, semua aplikasi akan memiliki pada sumber state yang sama. Konsep dasar provider Konsep dasar provider , hampir sama dengan state management pada umumnya. Ada satu pusat state yang diatur dalam mekanisme state management user interface atau komponen apa saja yang membutuhkan state atau data dari provider , bisa melakukan listen , dalam hal ini, komponen atau user interface terkait akan mengambil satu atau beberapa variable dari provider , kemudian akan melakukan listen , atau mengawasi perubahan data yang diambil tersebut. Jika terjadi perubahan, maka akan ada prosedur tertentu yang akan dilakukan, misal mengupdate tampilan sesuai perubahan data. Ini adalah fitur yang paling membantu dan sering digunakan. Komponen yang mengunakan, biasanya disebut listener once time access atau satukali akses, yang akan mendapatkan hasil data dari provider hanya pada saat diambil pada titik tertentu. Misal, hanya di akses pada constructor atau live cycle tertentu seperti didChangeDependencies() . Jadi tidak akan ada mekanisme listen Install provider Provider tidak disertakan secara builtin pada flutter. Kita harus men- setup terpisah. Untuk itu perlu dilakukan seperti setting package seperti dibawah ini: Buka file pubspec.yaml Buat baris baru setelah baris ke-25 Tambah code seperti tertera pada baris yang bertanda 23 24 25 26 27 28 dependencies: flutter: sdk: flutter provider: ^ 4.3 . 2 + 2 image_picker: ^ 0.6 . 7 + 14 mime: ^ 0.9 . 7 Simpan file pubspec.yaml , VS Code akan otomatis melakukan get untuk package provider . Jika tidak, jalankan perintah pada commandline: flutter pub get Membuat provider Membuat provider pada flutter cukup sederhana. Ada 2 komponen dasar yang harus dibuat yaitu: Model Kita dapat menganalogikan membuat model seperti mendefinisikan field atau nama kolom pada table sebuah database. Jadi bisa kita artikan model adalah sebuah definisi . Model tersebut di definisikan dengan menggunakan class biasa dari dart . Model pada dasarnya tidak mandatory, atau tidak wajib. Namun lebih bersifat pada ketergantungan dari pattern yang umum digunakan. Karena akan sulit memiliki record yang dishare antara Provider dan komponen yang me- listen . Hingga ahirnya, umumnya menjadi sebuah keharusan dalam membuat provider , kecuali pada kasus tertentu yang didalamnya tidak terdapat record , atau type data primitive bawaan dart, seperti integer, string dll. Provider Disinilah provider sesungguhnya mulai dibuat. Signature umum yang biasanya terdapat pada provider adalah sebagai berikut: keyword with ChangeNotifier keyword with ChangeNotifier didepan nama class, disebut mixin pada dart language. Fungsinya hampir seperti inheritance class pada dart dengan menggunakan keyword extend . Contoh: class BookListProvider with ChangeNotifier { Dengan melakukan mixin diatas terhadap class ChangeNotifier , provider yang kita definisikan, secara ajaib akan membangun channel yang berfungsi untuk memberitahu kepada listener atau komponen yang melakukan listen pada state tertentu. Mengenai listener akan kitabahas lebih lanjut nanti. Member variable List dengan generic type Disinilah definisi Model diatas berperan. Model yang sudah didefinisikan akan digunakan sebagai generic type dari sebuah variable dengan type List atau pada pemrograman lain biasa disebut Array . Member variable inilah yang nantinya akan digunakan dan di listen oleh komponen-komponen lainnya. Data tersebut sering disebut sebagai state , karena merupakan variable yang akan berubah2 dan menentukan state sebuah aplikasi. Contoh pendefinisian member variable untuk state dengan generic type: List < BookListModel > Member variable state bersifat private Ini adalah sebuah pattern wajib. Dengan membuat member variable dari state bersifat private, akan mencegah perubahan sembarangan dari luar mekanisme/pattern provider itu sendiri Dari contoh sebelumnya diatas mengenai generic type , contoh lengkapnya untuk membuat menjadi private sebagai berikut: List < BookListModel > _list = []; Membuat getter untuk mengambil state Komponen-komponen yang akan mengambil state dari provider , harus menggunakan fungsi khusus yang di sebut getter . Pada pemrograman dart , getter didefinisikan dengan menambah keyword get pada definisi fungsinya. Dengan format: <type> get <nama_getter>{ return ... } Menyambung contoh sebelumnya, getter untuk state _list diatas menjadi: List < BookListModel > get list { return [... this . _list ]; } Kenapa return harus ditulis return [...this._list]; ? karena jika hanya melakukan return this._list; listener tidak akan mendeteksi saat ada perubahan variable state _list . Ini adalah sifat alami dart , dimana variable akan di pass ke komponen lain berupa pointer atau alamatnya saja. Dengan me- return return [...this._list]; , dart akan memberikan variable baru sehingga alamat pointer akan berubah, dan listener akan tahu saat terjadi perubahan variable state terkait.","title":"Provider"},{"location":"crud-rest-api/provider/#provider","text":"Provider digunakan untuk beberapa tujuan. Salah satu kegunaan utamanya adalah untuk CRUD pada project pelatihan ini. Pada umumnya provider disebut juga sebagai state management , dimana sebuah aplikasi memiliki satu sumber data untuk semua user interface . Kita bisa membayangkan provider ini seperti database yang berisi satu atau lebih table . Sehingga, pada penggunaan dengan tujuan CRUD, provider berfungsi seperti database sementara pada saat terjadi Read dari server.","title":"Provider"},{"location":"crud-rest-api/provider/#latar-belakang-penggunaan-provider","text":"Konsep provider pada Flutter, sudah banyak dan populer digunakan pada platform lain, seperti Redux pada RreactJS atau NgRx dan NgXs pada Angular . Sebelum konspe state management seperti provider ini populer, data pada aplikasi antar user interface biasanya di pass berupa variable biasa dengan mengakses module/instance dari user interface yang memiliki data terkait. Hal ini akan sangat merepotkan, bayangkan saat kita memiliki sebuah input dialog , dari situ kita memerlukan data dari UI lain misal dari panel utama, kita harus memikirkan bagamana mem- pass data dari panel utama ke UI input dialog tersebut. Terlebih lagi jika pada suatu titik terjadi perubahan data pada panel utama tersebut. Dibandingkan dengan kosep provider ini atau yang umumnya disebut juga dengan state management . Data akan dapat diakses pada satu instance khusus. Jadi aplikasi kita akan memiliki single source of truth , yaitu, semua aplikasi akan memiliki pada sumber state yang sama.","title":"Latar belakang penggunaan provider"},{"location":"crud-rest-api/provider/#konsep-dasar-provider","text":"Konsep dasar provider , hampir sama dengan state management pada umumnya. Ada satu pusat state yang diatur dalam mekanisme state management user interface atau komponen apa saja yang membutuhkan state atau data dari provider , bisa melakukan listen , dalam hal ini, komponen atau user interface terkait akan mengambil satu atau beberapa variable dari provider , kemudian akan melakukan listen , atau mengawasi perubahan data yang diambil tersebut. Jika terjadi perubahan, maka akan ada prosedur tertentu yang akan dilakukan, misal mengupdate tampilan sesuai perubahan data. Ini adalah fitur yang paling membantu dan sering digunakan. Komponen yang mengunakan, biasanya disebut listener once time access atau satukali akses, yang akan mendapatkan hasil data dari provider hanya pada saat diambil pada titik tertentu. Misal, hanya di akses pada constructor atau live cycle tertentu seperti didChangeDependencies() . Jadi tidak akan ada mekanisme listen","title":"Konsep dasar provider"},{"location":"crud-rest-api/provider/#install-provider","text":"Provider tidak disertakan secara builtin pada flutter. Kita harus men- setup terpisah. Untuk itu perlu dilakukan seperti setting package seperti dibawah ini: Buka file pubspec.yaml Buat baris baru setelah baris ke-25 Tambah code seperti tertera pada baris yang bertanda 23 24 25 26 27 28 dependencies: flutter: sdk: flutter provider: ^ 4.3 . 2 + 2 image_picker: ^ 0.6 . 7 + 14 mime: ^ 0.9 . 7 Simpan file pubspec.yaml , VS Code akan otomatis melakukan get untuk package provider . Jika tidak, jalankan perintah pada commandline: flutter pub get","title":"Install provider"},{"location":"crud-rest-api/provider/#membuat-provider","text":"Membuat provider pada flutter cukup sederhana. Ada 2 komponen dasar yang harus dibuat yaitu: Model Kita dapat menganalogikan membuat model seperti mendefinisikan field atau nama kolom pada table sebuah database. Jadi bisa kita artikan model adalah sebuah definisi . Model tersebut di definisikan dengan menggunakan class biasa dari dart . Model pada dasarnya tidak mandatory, atau tidak wajib. Namun lebih bersifat pada ketergantungan dari pattern yang umum digunakan. Karena akan sulit memiliki record yang dishare antara Provider dan komponen yang me- listen . Hingga ahirnya, umumnya menjadi sebuah keharusan dalam membuat provider , kecuali pada kasus tertentu yang didalamnya tidak terdapat record , atau type data primitive bawaan dart, seperti integer, string dll. Provider Disinilah provider sesungguhnya mulai dibuat. Signature umum yang biasanya terdapat pada provider adalah sebagai berikut: keyword with ChangeNotifier keyword with ChangeNotifier didepan nama class, disebut mixin pada dart language. Fungsinya hampir seperti inheritance class pada dart dengan menggunakan keyword extend . Contoh: class BookListProvider with ChangeNotifier { Dengan melakukan mixin diatas terhadap class ChangeNotifier , provider yang kita definisikan, secara ajaib akan membangun channel yang berfungsi untuk memberitahu kepada listener atau komponen yang melakukan listen pada state tertentu. Mengenai listener akan kitabahas lebih lanjut nanti. Member variable List dengan generic type Disinilah definisi Model diatas berperan. Model yang sudah didefinisikan akan digunakan sebagai generic type dari sebuah variable dengan type List atau pada pemrograman lain biasa disebut Array . Member variable inilah yang nantinya akan digunakan dan di listen oleh komponen-komponen lainnya. Data tersebut sering disebut sebagai state , karena merupakan variable yang akan berubah2 dan menentukan state sebuah aplikasi. Contoh pendefinisian member variable untuk state dengan generic type: List < BookListModel > Member variable state bersifat private Ini adalah sebuah pattern wajib. Dengan membuat member variable dari state bersifat private, akan mencegah perubahan sembarangan dari luar mekanisme/pattern provider itu sendiri Dari contoh sebelumnya diatas mengenai generic type , contoh lengkapnya untuk membuat menjadi private sebagai berikut: List < BookListModel > _list = []; Membuat getter untuk mengambil state Komponen-komponen yang akan mengambil state dari provider , harus menggunakan fungsi khusus yang di sebut getter . Pada pemrograman dart , getter didefinisikan dengan menambah keyword get pada definisi fungsinya. Dengan format: <type> get <nama_getter>{ return ... } Menyambung contoh sebelumnya, getter untuk state _list diatas menjadi: List < BookListModel > get list { return [... this . _list ]; } Kenapa return harus ditulis return [...this._list]; ? karena jika hanya melakukan return this._list; listener tidak akan mendeteksi saat ada perubahan variable state _list . Ini adalah sifat alami dart , dimana variable akan di pass ke komponen lain berupa pointer atau alamatnya saja. Dengan me- return return [...this._list]; , dart akan memberikan variable baru sehingga alamat pointer akan berubah, dan listener akan tahu saat terjadi perubahan variable state terkait.","title":"Membuat provider"},{"location":"crud-rest-api/read/","text":"(R)ead Pada bagian (R)ead ini, kita akan membaca data dari REST API dengan response yang berformat JSON. Berdasarkan standard https://tools.ietf.org/html/rfc2616#section-9.3 , kita menggunakan GET sebagai \"HTTP verb\" untuk melakukan prosedur (R)ead ini. Hapus data mockup Langkah pertama, kita harus menghapus data-data mockup yang telah kita buat. Perhatikan dan hapus baris yang ter- highlight berikut: 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 ... // _list ini adalah model utama dari daftar buku kita // akan digunakan untuk menampilkan daftar buku // yang didapat dari REST API List < BookListModel > _list = [ // Kita buat dummy data atau data palsu // hanya untuk tujuan mockup dulu BookListModel ( id: \"1\" , title: \"Judul 1\" , imagePath: \"assets/book.png\" , ), BookListModel ( id: \"2\" , title: \"Judul 2\" , imagePath: \"assets/book.png\" , ), BookListModel ( id: \"3\" , title: \"Judul 3\" , imagePath: \"assets/book.png\" , ), ]; ... Sehingga menjadi: 62 63 64 65 66 67 ... // _list ini adalah model utama dari daftar buku kita // akan digunakan untuk menampilkan daftar buku // yang didapat dari REST API List < BookListModel > _list = []; ... Fungsi (R)ead di provider Seperti pada (C)reate, kita juga menggunakan provider untuk meletakkan fungsi (R)ead sesungguhnya yang terhubung langsung ke REST API. Untuk itu, buka kembali file lib/providers/booklist_provider.dart , kemudian perhatikan dan ubah/tambah code sesuai pada bagian yang ter- highlight berikut: 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 ... } catch ( e ) { // Jika terjadi error Map < String , dynamic > resInvalid = new Map < String , dynamic > (); resInvalid [ \"statusCode\" ] = statusCode != null ? statusCode : 400 ; resInvalid [ \"message\" ] = e . toString (); this . _isCreating = false ; notifyListeners (); //Prosedur standard untuk memberitahu \"listener\" bahwa ada perubahan return resInvalid ; } } // _isReading Digunakan untuk menampilkan \"loading indicator\" // Dan juga logic lain yang membutuhkannya bool _isReading = false ; // Getter dari _isReading bool get isReading { return this . _isReading ; } Future < void > read ( BuildContext context ) async { // Tandai \"true\" agar aplikasi tahu sedang terjadi proses (R)ead this . _isReading = true ; final settingData = Provider . of < SettingProvider > ( context , listen: false ); // Susun URL dengan menggunakan variable dari \"setting provider\" ditambah pattern API kita String url = \" ${ settingData . setting . apiHost } /perpus-api/booklist/ ${ settingData . setting . userName } \" ; // res adalah variable untuk menampung Response dari server http . Response res ; // ada kemungkinan error saat http.get(), jadi gunakan block \"try\" try { final resTmp = await http . get ( url ); res = resTmp ; } catch ( e ) { this . _isReading = false ; throw ( e ); } List < BookListModel > bookListData = ( json . decode ( res . body )[ \"data\" ] as List ) // Decode response sebagai \"List\" . map (( i ) => BookListModel . fromJson ( i )) // Format \"List\" agar sesuai dengan BookListModel . toList (); // Terakhir, convert agar jadi \"List of BookListModel\" ( List<BookListModel> ) // Menyimpan state ke variable _list, // ini variable yg akan dibaca oleh component yang membutuhkan daftar buku this . _list = bookListData ; // Kembalikan _isReading ke false yang berarti proses (R)ead selesai this . _isReading = false ; // notifyListeners() Memberitahukan kepada semua listener bahwa ada perubahan di provider ini notifyListeners (); } } \"Jahit\" API Request ke Grid Saat nya \"menjahit\" API Request kit Grid view yang telah kita buat. Jika sebelumnya kita menggunakan data \"mockup\", kali ini kita akan benar-benar mengambil dari REST API Server. Panggil read() dari BookListProvider Buka file lib/widgets/home/book-list.dart . Pada file ini, kita hanya akan memicu fungsi read() yang telah kita buat pada BookListProvider yang baru saja kita tambahkan. Dengan memanggil fungsi read() tersebut, aplikasi kita akan mem- fetch data dari REST API. Sehingga setelah proses selesai, component \"Grid view\" kita akan tahu ada perubahan data dan me- render nya. Perhatikan dan ubah/tambah sesuai code yang ter- highlight berikut: 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ... class _BookListState extends State < BookList > { // _isInitialized adalah helper variable // berguna untuk mencegah \"pemanggilan berulang\" // digunakan pada fungsi \"if\" dibawah // karena didChangeDependencies() pada komponen akan dipanggil lebih dari 1 kali bool _isInitialized ; @override void didChangeDependencies () { // If dibawah ini mencegah pemanggilan ganda dari blok didalamnya if ( this . _isInitialized == null || ! this . _isInitialized ) { context . read < BookListProvider > (). read ( context ); this . _isInitialized = true ; } // Memanggil \"parent\" didChangeDependencies(), harus selalu dilakukan super . didChangeDependencies (); } @override Widget build ( BuildContext context ) { ... Sebagai catatan, kita perlu melakukan pemanggilan super.didChangeDependencies(); pada akhir prosedur, karena kita telah meng override fungsi didChangeDependencies() . Yang mana fungsi tersebut adalah bagian dari Widget lifecycle . Oleh karena itu agar fungsi-fungsi standard tetap dijalankan setelah fungsi kita, kita harus memanggil super.didChangeDependencies(); agar lifecycle tersebut tetap berjalan seperti saat belum kita override Jalankan ulang aplikasi, tunggu beberapa saat. Jika semua sudah benar, seharusnya saat ini kita akan melihat aplikasi android kita sudah menggunakan data dari server yang sudah kita input sebelumnya. Tampilkan \"loading indicator\" Mengunggu tanpa kepastian akan membuat tidak nyaman, bahkan bisa membuat hayati lelah . Karena itu mari mari kita atur UX agar membuat user merasa nyaman dengan behavior dari aplikasi kita. UX adalah singkatan dari User experience , yang berkaitan erat dengan UI ( User interface ) pada bidang frontend development. Masih pada file lib/widgets/home/book-list.dart , perhatikan dan ubah/tambah sesuai code yang ter- highlight dibawah ini: 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 ... @override Widget build ( BuildContext context ) { var apiHost = Provider . of < SettingProvider > ( context , listen: false ). setting . apiHost ; List < BookListModel > bookList = context . watch < BookListProvider > (). list ; bool isReading = context . watch < BookListProvider > (). isReading ; return isReading == null || isReading ? Column ( mainAxisAlignment: MainAxisAlignment . center , children: < Widget > [ CircularProgressIndicator (), ], ) : GridView . builder ( padding: EdgeInsets . all ( 10 ), itemCount: bookList . length , itemBuilder: ( ctx , i ) => BookListItem ( id: bookList [ i ]. id , apiHost: apiHost , imagePath: bookList [ i ]. imagePath , title: bookList [ i ]. title , ), gridDelegate: SliverGridDelegateWithFixedCrossAxisCount ( crossAxisCount: 2 , childAspectRatio: 8 / 7 , crossAxisSpacing: 10 , mainAxisSpacing: 10 , ), ); Simpan dan jalankan dengan tombol restart . Seharusnya kita melihat tampilan \"loading indicator\" seperti dibawah ini:","title":"(R)ead"},{"location":"crud-rest-api/read/#read","text":"Pada bagian (R)ead ini, kita akan membaca data dari REST API dengan response yang berformat JSON. Berdasarkan standard https://tools.ietf.org/html/rfc2616#section-9.3 , kita menggunakan GET sebagai \"HTTP verb\" untuk melakukan prosedur (R)ead ini.","title":"(R)ead"},{"location":"crud-rest-api/read/#hapus-data-mockup","text":"Langkah pertama, kita harus menghapus data-data mockup yang telah kita buat. Perhatikan dan hapus baris yang ter- highlight berikut: 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 ... // _list ini adalah model utama dari daftar buku kita // akan digunakan untuk menampilkan daftar buku // yang didapat dari REST API List < BookListModel > _list = [ // Kita buat dummy data atau data palsu // hanya untuk tujuan mockup dulu BookListModel ( id: \"1\" , title: \"Judul 1\" , imagePath: \"assets/book.png\" , ), BookListModel ( id: \"2\" , title: \"Judul 2\" , imagePath: \"assets/book.png\" , ), BookListModel ( id: \"3\" , title: \"Judul 3\" , imagePath: \"assets/book.png\" , ), ]; ... Sehingga menjadi: 62 63 64 65 66 67 ... // _list ini adalah model utama dari daftar buku kita // akan digunakan untuk menampilkan daftar buku // yang didapat dari REST API List < BookListModel > _list = []; ...","title":"Hapus data mockup"},{"location":"crud-rest-api/read/#fungsi-read-di-provider","text":"Seperti pada (C)reate, kita juga menggunakan provider untuk meletakkan fungsi (R)ead sesungguhnya yang terhubung langsung ke REST API. Untuk itu, buka kembali file lib/providers/booklist_provider.dart , kemudian perhatikan dan ubah/tambah code sesuai pada bagian yang ter- highlight berikut: 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 ... } catch ( e ) { // Jika terjadi error Map < String , dynamic > resInvalid = new Map < String , dynamic > (); resInvalid [ \"statusCode\" ] = statusCode != null ? statusCode : 400 ; resInvalid [ \"message\" ] = e . toString (); this . _isCreating = false ; notifyListeners (); //Prosedur standard untuk memberitahu \"listener\" bahwa ada perubahan return resInvalid ; } } // _isReading Digunakan untuk menampilkan \"loading indicator\" // Dan juga logic lain yang membutuhkannya bool _isReading = false ; // Getter dari _isReading bool get isReading { return this . _isReading ; } Future < void > read ( BuildContext context ) async { // Tandai \"true\" agar aplikasi tahu sedang terjadi proses (R)ead this . _isReading = true ; final settingData = Provider . of < SettingProvider > ( context , listen: false ); // Susun URL dengan menggunakan variable dari \"setting provider\" ditambah pattern API kita String url = \" ${ settingData . setting . apiHost } /perpus-api/booklist/ ${ settingData . setting . userName } \" ; // res adalah variable untuk menampung Response dari server http . Response res ; // ada kemungkinan error saat http.get(), jadi gunakan block \"try\" try { final resTmp = await http . get ( url ); res = resTmp ; } catch ( e ) { this . _isReading = false ; throw ( e ); } List < BookListModel > bookListData = ( json . decode ( res . body )[ \"data\" ] as List ) // Decode response sebagai \"List\" . map (( i ) => BookListModel . fromJson ( i )) // Format \"List\" agar sesuai dengan BookListModel . toList (); // Terakhir, convert agar jadi \"List of BookListModel\" ( List<BookListModel> ) // Menyimpan state ke variable _list, // ini variable yg akan dibaca oleh component yang membutuhkan daftar buku this . _list = bookListData ; // Kembalikan _isReading ke false yang berarti proses (R)ead selesai this . _isReading = false ; // notifyListeners() Memberitahukan kepada semua listener bahwa ada perubahan di provider ini notifyListeners (); } }","title":"Fungsi (R)ead di provider"},{"location":"crud-rest-api/read/#jahit-api-request-ke-grid","text":"Saat nya \"menjahit\" API Request kit Grid view yang telah kita buat. Jika sebelumnya kita menggunakan data \"mockup\", kali ini kita akan benar-benar mengambil dari REST API Server.","title":"\"Jahit\" API Request ke Grid"},{"location":"crud-rest-api/read/#panggil-read-dari-booklistprovider","text":"Buka file lib/widgets/home/book-list.dart . Pada file ini, kita hanya akan memicu fungsi read() yang telah kita buat pada BookListProvider yang baru saja kita tambahkan. Dengan memanggil fungsi read() tersebut, aplikasi kita akan mem- fetch data dari REST API. Sehingga setelah proses selesai, component \"Grid view\" kita akan tahu ada perubahan data dan me- render nya. Perhatikan dan ubah/tambah sesuai code yang ter- highlight berikut: 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ... class _BookListState extends State < BookList > { // _isInitialized adalah helper variable // berguna untuk mencegah \"pemanggilan berulang\" // digunakan pada fungsi \"if\" dibawah // karena didChangeDependencies() pada komponen akan dipanggil lebih dari 1 kali bool _isInitialized ; @override void didChangeDependencies () { // If dibawah ini mencegah pemanggilan ganda dari blok didalamnya if ( this . _isInitialized == null || ! this . _isInitialized ) { context . read < BookListProvider > (). read ( context ); this . _isInitialized = true ; } // Memanggil \"parent\" didChangeDependencies(), harus selalu dilakukan super . didChangeDependencies (); } @override Widget build ( BuildContext context ) { ... Sebagai catatan, kita perlu melakukan pemanggilan super.didChangeDependencies(); pada akhir prosedur, karena kita telah meng override fungsi didChangeDependencies() . Yang mana fungsi tersebut adalah bagian dari Widget lifecycle . Oleh karena itu agar fungsi-fungsi standard tetap dijalankan setelah fungsi kita, kita harus memanggil super.didChangeDependencies(); agar lifecycle tersebut tetap berjalan seperti saat belum kita override Jalankan ulang aplikasi, tunggu beberapa saat. Jika semua sudah benar, seharusnya saat ini kita akan melihat aplikasi android kita sudah menggunakan data dari server yang sudah kita input sebelumnya.","title":"Panggil read() dari BookListProvider"},{"location":"crud-rest-api/read/#tampilkan-loading-indicator","text":"Mengunggu tanpa kepastian akan membuat tidak nyaman, bahkan bisa membuat hayati lelah . Karena itu mari mari kita atur UX agar membuat user merasa nyaman dengan behavior dari aplikasi kita. UX adalah singkatan dari User experience , yang berkaitan erat dengan UI ( User interface ) pada bidang frontend development. Masih pada file lib/widgets/home/book-list.dart , perhatikan dan ubah/tambah sesuai code yang ter- highlight dibawah ini: 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 ... @override Widget build ( BuildContext context ) { var apiHost = Provider . of < SettingProvider > ( context , listen: false ). setting . apiHost ; List < BookListModel > bookList = context . watch < BookListProvider > (). list ; bool isReading = context . watch < BookListProvider > (). isReading ; return isReading == null || isReading ? Column ( mainAxisAlignment: MainAxisAlignment . center , children: < Widget > [ CircularProgressIndicator (), ], ) : GridView . builder ( padding: EdgeInsets . all ( 10 ), itemCount: bookList . length , itemBuilder: ( ctx , i ) => BookListItem ( id: bookList [ i ]. id , apiHost: apiHost , imagePath: bookList [ i ]. imagePath , title: bookList [ i ]. title , ), gridDelegate: SliverGridDelegateWithFixedCrossAxisCount ( crossAxisCount: 2 , childAspectRatio: 8 / 7 , crossAxisSpacing: 10 , mainAxisSpacing: 10 , ), ); Simpan dan jalankan dengan tombol restart . Seharusnya kita melihat tampilan \"loading indicator\" seperti dibawah ini:","title":"Tampilkan \"loading indicator\""}]}